{"version":3,"file":"js/3360.025d89bb.js","mappings":"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","sources":["webpack://app/../../../../src/plugins/guestIdentity/GuestIdentityDriver.ts","webpack://app/../../../../src/plugins/guestIdentity/plugin.ts","webpack://app/../../../../src/plugins/identityModule/IdentityClient.ts","webpack://app/../../../../src/plugins/identityModule/plugin.ts","webpack://app/../../../../src/plugins/keypairIdentity/KeypairIdentityDriver.ts","webpack://app/../../../../src/plugins/irysStorage/IrysStorageDriver.ts","webpack://app/../../../../src/plugins/irysStorage/plugin.ts","webpack://app/../../../../src/plugins/nftModule/models/Nft.ts","webpack://app/../../../../src/plugins/nftModule/models/Sft.ts","webpack://app/../../../../src/plugins/nftModule/helpers.ts","webpack://app/../../../../src/plugins/nftModule/operations/createCompressedNft.ts","webpack://app/../../../../src/plugins/nftModule/operations/createNft.ts","webpack://app/../../../../src/plugins/nftModule/models/Metadata.ts","webpack://app/../../../../src/plugins/nftModule/operations/createSft.ts","webpack://app/../../../../src/plugins/nftModule/accounts.ts","webpack://app/../../../../src/plugins/nftModule/models/NftEdition.ts","webpack://app/../../../../src/plugins/nftModule/operations/printNewEdition.ts","webpack://app/../../../../src/plugins/nftModule/DelegateInput.ts","webpack://app/../../../../src/plugins/nftModule/Authorization.ts","webpack://app/../../../../src/plugins/nftModule/operations/updateNft.ts","webpack://app/../../../../src/plugins/nftModule/operations/deleteNft.ts","webpack://app/../../../../src/plugins/nftModule/errors.ts","webpack://app/../../../../src/plugins/nftModule/DelegateType.ts","webpack://app/../../../../src/plugins/nftModule/operations/approveNftDelegate.ts","webpack://app/../../../../src/plugins/nftModule/operations/revokeNftDelegate.ts","webpack://app/../../../../src/plugins/nftModule/operations/useNft.ts","webpack://app/../../../../src/plugins/nftModule/operations/approveNftUseAuthority.ts","webpack://app/../../../../src/plugins/nftModule/operations/revokeNftUseAuthority.ts","webpack://app/../../../../src/plugins/nftModule/operations/verifyNftCreator.ts","webpack://app/../../../../src/plugins/nftModule/operations/unverifyNftCreator.ts","webpack://app/../../../../src/plugins/nftModule/operations/verifyNftCollection.ts","webpack://app/../../../../src/plugins/nftModule/operations/unverifyNftCollection.ts","webpack://app/../../../../src/plugins/nftModule/operations/approveNftCollectionAuthority.ts","webpack://app/../../../../src/plugins/nftModule/operations/revokeNftCollectionAuthority.ts","webpack://app/../../../../src/plugins/nftModule/operations/migrateToSizedCollectionNft.ts","webpack://app/../../../../src/plugins/nftModule/operations/lockNft.ts","webpack://app/../../../../src/plugins/nftModule/operations/unlockNft.ts","webpack://app/../../../../src/plugins/nftModule/operations/mintNft.ts","webpack://app/../../../../src/plugins/nftModule/operations/transferCompressedNft.ts","webpack://app/../../../../src/plugins/nftModule/operations/transferNft.ts","webpack://app/../../../../src/plugins/nftModule/operations/freezeDelegatedNft.ts","webpack://app/../../../../src/plugins/nftModule/operations/thawDelegatedNft.ts","webpack://app/../../../../src/plugins/nftModule/NftBuildersClient.ts","webpack://app/../../../../src/plugins/nftModule/NftPdasClient.ts","webpack://app/../../../../src/plugins/nftModule/operations/findNftByAssetId.ts","webpack://app/../../../../src/plugins/nftModule/operations/findNftByMint.ts","webpack://app/../../../../src/plugins/nftModule/operations/findNftByMetadata.ts","webpack://app/../../../../src/plugins/nftModule/operations/findNftByToken.ts","webpack://app/../../../../src/plugins/nftModule/gpaBuilders.ts","webpack://app/../../../../src/plugins/nftModule/operations/findNftsByCreator.ts","webpack://app/../../../../src/plugins/nftModule/operations/findNftsByMintList.ts","webpack://app/../../../../src/plugins/nftModule/operations/findNftsByOwner.ts","webpack://app/../../../../src/plugins/nftModule/operations/findNftsByUpdateAuthority.ts","webpack://app/../../../../src/plugins/nftModule/operations/loadMetadata.ts","webpack://app/../../../../src/plugins/nftModule/operations/uploadMetadata.ts","webpack://app/../../../../src/plugins/nftModule/NftClient.ts","webpack://app/../../../../src/plugins/nftModule/plugin.ts","webpack://app/../../../../src/plugins/operationModule/OperationClient.ts","webpack://app/../../../../src/plugins/operationModule/plugin.ts","webpack://app/../../../../src/plugins/programModule/ProgramClient.ts","webpack://app/../../../../src/plugins/programModule/plugin.ts","webpack://app/../../../../src/plugins/rpcModule/RpcClient.ts","webpack://app/../../../../src/plugins/rpcModule/plugin.ts","webpack://app/../../../../src/plugins/storageModule/MetaplexFile.ts","webpack://app/../../../../src/plugins/storageModule/StorageClient.ts","webpack://app/../../../../src/plugins/storageModule/plugin.ts","webpack://app/../../../../src/plugins/systemModule/operations/createAccount.ts","webpack://app/../../../../src/plugins/systemModule/operations/transferSol.ts","webpack://app/../../../../src/plugins/systemModule/SystemBuildersClient.ts","webpack://app/../../../../src/plugins/systemModule/SystemClient.ts","webpack://app/../../../../src/plugins/systemModule/plugin.ts"],"sourcesContent":["import { PublicKey, Transaction } from '@solana/web3.js';\nimport { IdentityDriver } from '../identityModule';\nimport { OperationUnauthorizedForGuestsError } from '@/errors';\n\nexport class GuestIdentityDriver implements IdentityDriver {\n  public readonly publicKey: PublicKey;\n\n  constructor(publicKey?: PublicKey) {\n    this.publicKey = publicKey ?? PublicKey.default;\n  }\n\n  public async signMessage(): Promise<Uint8Array> {\n    throw new OperationUnauthorizedForGuestsError('signMessage');\n  }\n\n  public async signTransaction(): Promise<Transaction> {\n    throw new OperationUnauthorizedForGuestsError('signTransaction');\n  }\n\n  public async signAllTransactions(): Promise<Transaction[]> {\n    throw new OperationUnauthorizedForGuestsError('signAllTransactions');\n  }\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { GuestIdentityDriver } from './GuestIdentityDriver';\nimport { Metaplex } from '@/Metaplex';\nimport { MetaplexPlugin } from '@/types';\n\n/** @group Plugins */\nexport const guestIdentity = (publicKey?: PublicKey): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    metaplex.identity().setDriver(new GuestIdentityDriver(publicKey));\n  },\n});\n","import * as ed25519 from '@noble/ed25519';\nimport { PublicKey, Transaction } from '@solana/web3.js';\nimport { IdentityDriver } from './IdentityDriver';\nimport {\n  HasDriver,\n  IdentitySigner,\n  isSigner,\n  KeypairSigner,\n  Signer,\n} from '@/types';\nimport { DriverNotProvidedError } from '@/errors';\n\n/**\n * @group Modules\n */\nexport class IdentityClient\n  implements HasDriver<IdentityDriver>, IdentitySigner\n{\n  private _driver: IdentityDriver | null = null;\n\n  driver(): IdentityDriver {\n    if (!this._driver) {\n      throw new DriverNotProvidedError('IdentityDriver');\n    }\n\n    return this._driver;\n  }\n\n  setDriver(newDriver: IdentityDriver): void {\n    this._driver = newDriver;\n  }\n\n  get publicKey(): PublicKey {\n    return this.driver().publicKey;\n  }\n\n  get secretKey(): Uint8Array | undefined {\n    return this.driver().secretKey;\n  }\n\n  signMessage(message: Uint8Array): Promise<Uint8Array> {\n    return this.driver().signMessage(message);\n  }\n\n  signTransaction(transaction: Transaction): Promise<Transaction> {\n    return this.driver().signTransaction(transaction);\n  }\n\n  signAllTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n    return this.driver().signAllTransactions(transactions);\n  }\n\n  verifyMessage(message: Uint8Array, signature: Uint8Array): boolean {\n    return ed25519.sync.verify(message, signature, this.publicKey.toBytes());\n  }\n\n  equals(that: Signer | PublicKey): boolean {\n    if (isSigner(that)) {\n      that = that.publicKey;\n    }\n\n    return this.publicKey.equals(that);\n  }\n\n  hasSecretKey(): this is KeypairSigner {\n    return this.secretKey != null;\n  }\n}\n","import { IdentityClient } from './IdentityClient';\nimport type { Metaplex } from '@/Metaplex';\nimport { MetaplexPlugin } from '@/types';\n\n/** @group Plugins */\nexport const identityModule = (): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    const identityClient = new IdentityClient();\n    metaplex.identity = () => identityClient;\n  },\n});\n\ndeclare module '../../Metaplex' {\n  interface Metaplex {\n    identity(): IdentityClient;\n  }\n}\n","import * as ed25519 from '@noble/ed25519';\nimport { Keypair, PublicKey, Transaction } from '@solana/web3.js';\nimport { IdentityDriver } from '../identityModule';\nimport { KeypairSigner } from '@/types';\n\nexport class KeypairIdentityDriver implements IdentityDriver, KeypairSigner {\n  public readonly keypair: Keypair;\n  public readonly publicKey: PublicKey;\n  public readonly secretKey: Uint8Array;\n\n  constructor(keypair: Keypair) {\n    this.keypair = keypair;\n    this.publicKey = keypair.publicKey;\n    this.secretKey = keypair.secretKey;\n  }\n\n  public async signMessage(message: Uint8Array): Promise<Uint8Array> {\n    return ed25519.sync.sign(message, this.secretKey.slice(0, 32));\n  }\n\n  public async signTransaction(transaction: Transaction): Promise<Transaction> {\n    transaction.partialSign(this.keypair);\n\n    return transaction;\n  }\n\n  public async signAllTransactions(\n    transactions: Transaction[]\n  ): Promise<Transaction[]> {\n    return Promise.all(\n      transactions.map((transaction) => this.signTransaction(transaction))\n    );\n  }\n}\n","import type { default as NodeIrys, WebIrys } from '@irys/sdk';\n\nimport BigNumber from 'bignumber.js';\nimport {\n  Connection,\n  Keypair,\n  PublicKey,\n  SendOptions,\n  Signer as Web3Signer,\n  Transaction,\n  TransactionSignature,\n} from '@solana/web3.js';\nimport {\n  getBytesFromMetaplexFiles,\n  MetaplexFile,\n  MetaplexFileTag,\n  StorageDriver,\n} from '../storageModule';\nimport { KeypairIdentityDriver } from '../keypairIdentity';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Amount,\n  IdentitySigner,\n  isIdentitySigner,\n  isKeypairSigner,\n  KeypairSigner,\n  lamports,\n  Signer,\n  toBigNumber,\n} from '@/types';\nimport {\n  AssetUploadFailedError,\n  FailedToConnectToIrysAddressError,\n  FailedToInitializeIrysError,\n  IrysWithdrawError,\n} from '@/errors';\nimport { _removeDoubleDefault } from '@/utils';\n\nexport type IrysOptions = {\n  address?: string;\n  timeout?: number;\n  providerUrl?: string;\n  priceMultiplier?: number;\n  identity?: Signer;\n};\n\nexport type IrysWalletAdapter = {\n  publicKey: PublicKey | null;\n  signMessage?: (message: Uint8Array) => Promise<Uint8Array>;\n  signTransaction?: (transaction: Transaction) => Promise<Transaction>;\n  signAllTransactions?: (transactions: Transaction[]) => Promise<Transaction[]>;\n  sendTransaction: (\n    transaction: Transaction,\n    connection: Connection,\n    options?: SendOptions & { signers?: Web3Signer[] }\n  ) => Promise<TransactionSignature>;\n};\n\n/// Size of irys transaction header\nconst HEADER_SIZE = 2_000;\n\n/// Minimum file size for cost calculation\nconst MINIMUM_SIZE = 80_000;\n\nexport class IrysStorageDriver implements StorageDriver {\n  protected _metaplex: Metaplex;\n  protected _irys: WebIrys | NodeIrys | null = null;\n  protected _options: IrysOptions;\n\n  constructor(metaplex: Metaplex, options: IrysOptions = {}) {\n    this._metaplex = metaplex;\n    this._options = {\n      providerUrl: metaplex.connection.rpcEndpoint,\n      ...options,\n    };\n  }\n\n  async getUploadPrice(bytes: number): Promise<Amount> {\n    const irys = await this.irys();\n    const price = await irys.getPrice(bytes);\n\n    return bigNumberToAmount(\n      price.multipliedBy(this._options.priceMultiplier ?? 1.1)\n    );\n  }\n\n  async getUploadPriceForFiles(files: MetaplexFile[]): Promise<Amount> {\n    const bytes: number = files.reduce((sum, file) => {\n      return sum + HEADER_SIZE + Math.max(MINIMUM_SIZE, file.buffer.byteLength);\n    }, 0);\n\n    return this.getUploadPrice(bytes);\n  }\n\n  async upload(file: MetaplexFile): Promise<string> {\n    const [uri] = await this.uploadAll([file]);\n\n    return uri;\n  }\n\n  async uploadAll(files: MetaplexFile[]): Promise<string[]> {\n    const irys = await this.irys();\n    const amount = await this.getUploadPrice(\n      getBytesFromMetaplexFiles(...files)\n    );\n    await this.fund(amount);\n\n    const promises = files.map(async (file) => {\n      const irysTx = irys.createTransaction(file.buffer, {\n        tags: getMetaplexFileTagsWithContentType(file),\n      });\n      await irysTx.sign();\n\n      const { status, data } = await irys.uploader.uploadTransaction(irysTx);\n\n      if (status >= 300) {\n        throw new AssetUploadFailedError(status);\n      }\n\n      return `https://arweave.net/${data.id}`;\n    });\n\n    return await Promise.all(promises);\n  }\n\n  async getBalance(): Promise<Amount> {\n    const irys = await this.irys();\n    const balance = await irys.getLoadedBalance();\n\n    return bigNumberToAmount(balance);\n  }\n\n  async fund(amount: Amount, skipBalanceCheck = false): Promise<void> {\n    const irys = await this.irys();\n    let toFund = amountToBigNumber(amount);\n\n    if (!skipBalanceCheck) {\n      const balance = await irys.getLoadedBalance();\n\n      toFund = toFund.isGreaterThan(balance)\n        ? toFund.minus(balance)\n        : new BigNumber(0);\n    }\n\n    if (toFund.isLessThanOrEqualTo(0)) {\n      return;\n    }\n\n    // TODO: Catch errors and wrap in irysErrors.\n    await irys.fund(toFund);\n  }\n\n  async withdrawAll(): Promise<void> {\n    // TODO(loris): Replace with \"withdrawAll\" when available on irys.\n    const irys = await this.irys();\n    const balance = await irys.getLoadedBalance();\n    const minimumBalance = new BigNumber(5000);\n\n    if (balance.isLessThan(minimumBalance)) {\n      return;\n    }\n\n    const balanceToWithdraw = balance.minus(minimumBalance);\n    await this.withdraw(bigNumberToAmount(balanceToWithdraw));\n  }\n\n  async withdraw(amount: Amount): Promise<void> {\n    const irys = await this.irys();\n    try {\n      await irys.withdrawBalance(amountToBigNumber(amount));\n    } catch (e: any) {\n      throw new IrysWithdrawError(\n        e instanceof Error ? e.message : e.toString()\n      );\n    }\n  }\n\n  async irys(): Promise<WebIrys | NodeIrys> {\n    if (this._irys) {\n      return this._irys;\n    }\n\n    return (this._irys = await this.initIrys());\n  }\n\n  async initIrys(): Promise<WebIrys | NodeIrys> {\n    const currency = 'solana';\n    const address = this._options?.address ?? 'https://node1.irys.xyz';\n    const options = {\n      timeout: this._options.timeout,\n      providerUrl: this._options.providerUrl,\n    };\n\n    const identity: Signer =\n      this._options.identity ?? this._metaplex.identity();\n\n    // if in node use node irys, else use web irys\n    // see: https://github.com/metaplex-foundation/js/issues/202\n    const isNode =\n      typeof window === 'undefined' || window.process?.hasOwnProperty('type');\n    let irys;\n    if (isNode && isKeypairSigner(identity))\n      irys = await this.initNodeirys(address, currency, identity, options);\n    else {\n      let identitySigner: IdentitySigner;\n      if (isIdentitySigner(identity)) identitySigner = identity;\n      else\n        identitySigner = new KeypairIdentityDriver(\n          Keypair.fromSecretKey((identity as KeypairSigner).secretKey)\n        );\n\n      irys = await this.initWebirys(address, currency, identitySigner, options);\n    }\n\n    try {\n      // Check for valid irys node.\n      await irys.utils.getBundlerAddress(currency);\n    } catch (error) {\n      throw new FailedToConnectToIrysAddressError(address, error as Error);\n    }\n\n    return irys;\n  }\n\n  async initNodeirys(\n    address: string,\n    currency: string,\n    keypair: KeypairSigner,\n    options: any\n  ): Promise<NodeIrys> {\n    const bPackage = _removeDoubleDefault(await import('@irys/sdk'));\n    return new bPackage.default({\n      url: address,\n      token: currency,\n      key: keypair.secretKey,\n      config: options,\n    });\n  }\n\n  async initWebirys(\n    address: string,\n    currency: string,\n    identity: IdentitySigner,\n    options: any\n  ): Promise<WebIrys> {\n    const wallet: IrysWalletAdapter = {\n      publicKey: identity.publicKey,\n      signMessage: (message: Uint8Array) => identity.signMessage(message),\n      signTransaction: (transaction: Transaction) =>\n        identity.signTransaction(transaction),\n      signAllTransactions: (transactions: Transaction[]) =>\n        identity.signAllTransactions(transactions),\n      sendTransaction: (\n        transaction: Transaction,\n        connection: Connection,\n        options: SendOptions & { signers?: Web3Signer[] } = {}\n      ): Promise<TransactionSignature> => {\n        const { signers = [], ...sendOptions } = options;\n\n        return this._metaplex\n          .rpc()\n          .sendTransaction(transaction, sendOptions, [identity, ...signers]);\n      },\n    };\n\n    const bPackage = _removeDoubleDefault(await import('@irys/sdk'));\n    const irys = new bPackage.WebIrys({\n      url: address,\n      token: currency,\n      wallet: { provider: wallet },\n      config: options,\n    });\n\n    try {\n      // Try to initiate irys.\n      await irys.ready();\n    } catch (error) {\n      throw new FailedToInitializeIrysError(error as Error);\n    }\n\n    return irys;\n  }\n}\n\nexport const isirysStorageDriver = (\n  storageDriver: StorageDriver\n): storageDriver is IrysStorageDriver => {\n  return (\n    'irys' in storageDriver &&\n    'getBalance' in storageDriver &&\n    'fund' in storageDriver &&\n    'withdrawAll' in storageDriver\n  );\n};\n\nconst bigNumberToAmount = (bigNumber: BigNumber): Amount => {\n  return lamports(toBigNumber(bigNumber.decimalPlaces(0).toString()));\n};\n\nconst amountToBigNumber = (amount: Amount): BigNumber => {\n  return new BigNumber(amount.basisPoints.toString());\n};\n\nconst getMetaplexFileTagsWithContentType = (\n  file: MetaplexFile\n): MetaplexFileTag[] => {\n  if (!file.contentType) {\n    return file.tags;\n  }\n\n  return [{ name: 'Content-Type', value: file.contentType }, ...file.tags];\n};\n","import { IrysOptions, IrysStorageDriver } from './IrysStorageDriver';\nimport { Metaplex } from '@/Metaplex';\nimport { MetaplexPlugin } from '@/types';\n\nexport const irysStorage = (options: IrysOptions = {}): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    metaplex.storage().setDriver(new IrysStorageDriver(metaplex, options));\n  },\n});\n","import type { PublicKey } from '@solana/web3.js';\nimport type { Mint, Token } from '../../tokenModule';\nimport type { Metadata } from './Metadata';\nimport type { NftEdition } from './NftEdition';\nimport { isSftWithToken, SftWithToken, toSft, toSftWithToken } from './Sft';\nimport { assert } from '@/utils';\nimport type { Pda } from '@/types';\n\n/**\n * This model captures all the relevant information about an NFT\n * in the Solana blockchain. That includes the NFT's metadata account,\n * its mint account, its edition account and its off-chain JSON metadata.\n *\n * @group Models\n */\nexport type Nft = Omit<Metadata, 'model' | 'address' | 'mintAddress'> & {\n  /** A model identifier to distinguish models in the SDK. */\n  readonly model: 'nft';\n\n  /** The mint address of the NFT. */\n  readonly address: PublicKey;\n\n  /** The metadata address of the NFT. */\n  readonly metadataAddress: Pda;\n\n  /** The mint account of the NFT. */\n  readonly mint: Mint;\n\n  /**\n   * Defines whether the NFT is an original edition or a\n   * printed edition and provides additional information accordingly.\n   */\n  readonly edition: NftEdition;\n};\n\n/** @group Model Helpers */\nexport const isNft = (value: any): value is Nft =>\n  typeof value === 'object' && value.model === 'nft';\n\n/** @group Model Helpers */\nexport function assertNft(value: any): asserts value is Nft {\n  assert(isNft(value), `Expected Nft model`);\n}\n\n/** @group Model Helpers */\nexport const toNft = (\n  metadata: Metadata,\n  mint: Mint,\n  edition: NftEdition\n): Nft => ({\n  ...toSft(metadata, mint),\n  model: 'nft',\n  edition,\n});\n\n/** @group Models */\nexport type NftWithToken = Nft & { token: Token };\n\n/** @group Model Helpers */\nexport const isNftWithToken = (value: any): value is NftWithToken =>\n  isNft(value) && 'token' in value;\n\n/** @group Model Helpers */\nexport function assertNftWithToken(value: any): asserts value is NftWithToken {\n  assert(isNftWithToken(value), `Expected Nft model with token`);\n}\n\n/** @group Model Helpers */\nexport function assertNftOrSftWithToken(\n  value: any\n): asserts value is NftWithToken | SftWithToken {\n  assert(\n    isNftWithToken(value) || isSftWithToken(value),\n    `Expected Nft or Sft model with token`\n  );\n}\n\n/** @group Model Helpers */\nexport const toNftWithToken = (\n  metadata: Metadata,\n  mint: Mint,\n  edition: NftEdition,\n  token: Token\n): NftWithToken => ({\n  ...toSftWithToken(metadata, mint, token),\n  model: 'nft',\n  edition,\n});\n","import type { PublicKey } from '@solana/web3.js';\nimport type { Mint, Token } from '../../tokenModule';\nimport type { Metadata } from './Metadata';\nimport { assert } from '@/utils';\nimport { amount, Pda } from '@/types';\n\n/** @group Models */\nexport type Sft = Omit<Metadata, 'model' | 'address' | 'mintAddress'> &\n  Readonly<{\n    model: 'sft';\n\n    /** The mint address of the SFT. */\n    address: PublicKey;\n\n    /** The metadata address of the SFT. */\n    metadataAddress: Pda;\n\n    /** The mint account of the SFT. */\n    mint: Mint;\n  }>;\n\n/** @group Model Helpers */\nexport const isSft = (value: any): value is Sft =>\n  typeof value === 'object' && value.model === 'sft';\n\n/** @group Model Helpers */\nexport function assertSft(value: any): asserts value is Sft {\n  assert(isSft(value), `Expected Sft model`);\n}\n\n/** @group Model Helpers */\nexport const toSft = (metadata: Metadata, mint: Mint): Sft => {\n  const { address, mintAddress, ...shared } = metadata;\n  assert(\n    mintAddress.equals(mint.address),\n    'The provided mint does not match the mint address in the metadata'\n  );\n\n  const currency = {\n    ...mint.currency,\n    symbol: metadata.symbol || 'Token',\n  };\n\n  return {\n    ...shared,\n    model: 'sft',\n    address: mintAddress,\n    metadataAddress: address,\n    mint: {\n      ...mint,\n      currency,\n      supply: amount(mint.supply.basisPoints, currency),\n    },\n  };\n};\n\n/** @group Models */\nexport type SftWithToken = Sft & { token: Token };\n\n/** @group Model Helpers */\nexport const isSftWithToken = (value: any): value is SftWithToken =>\n  isSft(value) && 'token' in value;\n\n/** @group Model Helpers */\nexport function assertSftWithToken(value: any): asserts value is SftWithToken {\n  assert(isSftWithToken(value), `Expected Sft model with token`);\n}\n\n/** @group Model Helpers */\nexport const toSftWithToken = (\n  metadata: Metadata,\n  mint: Mint,\n  token: Token\n): SftWithToken => {\n  const sft = toSft(metadata, mint);\n  const { currency } = sft.mint;\n  return {\n    ...sft,\n    token: {\n      ...token,\n      amount: amount(token.amount.basisPoints, currency),\n      delegateAmount: amount(token.delegateAmount.basisPoints, currency),\n    },\n  };\n};\n","import type { PublicKey } from '@solana/web3.js';\nimport type { Nft, NftWithToken, Sft, SftWithToken } from './models';\nimport type { Metadata } from './models/Metadata';\nimport { PublicKeyValues, toPublicKey } from '@/types';\n\nexport type HasMintAddress =\n  | Nft\n  | Sft\n  | NftWithToken\n  | SftWithToken\n  | Metadata\n  | PublicKey;\n\nexport const toMintAddress = (\n  value: PublicKeyValues | HasMintAddress\n): PublicKey => {\n  return typeof value === 'object' && 'mintAddress' in value\n    ? value.mintAddress\n    : toPublicKey(value);\n};\n","import {\n  Uses,\n  PROGRAM_ID as TOKEN_METADATA_PROGRAM_ID,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport {\n  TokenProgramVersion,\n  createMintToCollectionV1Instruction,\n  getLeafAssetId,\n  TokenStandard,\n  PROGRAM_ID as BUBBLEGUM_PROGRAM_ID,\n} from '@metaplex-foundation/mpl-bubblegum';\nimport {\n  SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,\n  SPL_NOOP_PROGRAM_ID,\n  deserializeChangeLogEventV1,\n} from '@solana/spl-account-compression';\nimport { PublicKey } from '@solana/web3.js';\nimport { BN } from 'bn.js';\nimport base58 from 'bs58';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { assertNft, Nft } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Creator,\n  CreatorInput,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateCompressedNftOperation' as const;\n\n/**\n * Creates a new compressed NFT.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .nfts()\n *   .createNft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-nft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *     tree: merkleTreeAccount\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createCompressedNftOperation =\n  useOperation<CreateCompressedNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateCompressedNftOperation = Operation<\n  typeof Key,\n  CreateCompressedNftInput,\n  CreateCompressedNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateCompressedNftInput = {\n  /**\n   * The authority that will be able to make changes\n   * to the created SFT.\n   *\n   * This is required as a Signer because creating the\n   * metadata account requires the update authority to be part\n   * of the creators array as a verified creator.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  updateAuthority?: Signer;\n\n  /**\n   * The address corresponding to the merkle tree where this\n   * compressed NFT will be stored.\n   *\n   * Must be created ahead of time.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  tree: PublicKey;\n\n  /**\n   * The owner of a token account associated with the SFT to create.\n   *\n   * This is completely optional as creating an SFT does not require\n   * the existence of a token account. When provided, an associated\n   * token account will be created from the given owner.\n   *\n   * You may alternatively pass the `tokenAddress` parameter instead.\n   *\n   * @defaultValue Defaults to not creating and/or minting\n   * any token account.\n   */\n  tokenOwner?: PublicKey;\n\n  /** The URI that points to the JSON metadata of the asset. */\n  uri: string;\n\n  /** The on-chain name of the asset, e.g. \"My SFT\". */\n  name: string;\n\n  /**\n   * The royalties in percent basis point (i.e. 250 is 2.5%) that\n   * should be paid to the creators on each secondary sale.\n   */\n  sellerFeeBasisPoints: number;\n\n  /**\n   * The on-chain symbol of the asset, stored in the Metadata account.\n   * E.g. \"MYSFT\".\n   *\n   * @defaultValue `\"\"`\n   */\n  symbol?: string;\n\n  /**\n   * {@inheritDoc CreatorInput}\n   * @defaultValue\n   * Defaults to using the provided `updateAuthority` as the only verified creator.\n   * ```ts\n   * [{\n   *   address: updateAuthority.publicKey,\n   *   authority: updateAuthority,\n   *   share: 100,\n   * }]\n   * ```\n   */\n  creators?: CreatorInput[];\n\n  /**\n   * Whether or not the SFT's metadata is mutable.\n   * When set to `false` no one can update the Metadata account,\n   * not even the update authority.\n   *\n   * @defaultValue `true`\n   */\n  isMutable?: boolean;\n\n  /**\n   * When this field is not `null`, it indicates that the SFT\n   * can be \"used\" by its owner or any approved \"use authorities\".\n   *\n   * @defaultValue `null`\n   */\n  uses?: Option<Uses>;\n\n  /**\n   * The Collection NFT that this new SFT belongs to.\n   * When `null`, the created SFT will not be part of a collection.\n   *\n   * @defaultValue `null`\n   */\n  collection?: Option<PublicKey>;\n\n  /**\n   * The collection authority that should sign the created SFT\n   * to prove that it is part of the provided collection.\n   * When `null`, the provided `collection` will not be verified.\n   *\n   * @defaultValue `null`\n   */\n  collectionAuthority?: Option<Signer>;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority\n   * using `metaplex.nfts().approveCollectionAuthority()`.\n   *\n   * @defaultValue `false`\n   */\n  collectionAuthorityIsDelegated?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateCompressedNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created NFT and, potentially, its associated token. */\n  nft: Nft;\n\n  /** The mint address is the compressed NFT's assetId. */\n  mintAddress: PublicKey;\n\n  /** The metadata address is the compressed NFT's assetId. */\n  metadataAddress: PublicKey;\n\n  /** The master edition address is the compressed NFT's assetId. */\n  masterEditionAddress: PublicKey;\n\n  /** The token address is the compressed NFT's assetId. */\n  tokenAddress: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createCompressedNftOperationHandler: OperationHandler<CreateCompressedNftOperation> =\n  {\n    handle: async (\n      operation: CreateCompressedNftOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ) => {\n      const builder = await createCompressedNftBuilder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const txInfo = await metaplex.connection.getTransaction(\n        output.response.signature,\n        {\n          maxSupportedTransactionVersion: 0,\n        }\n      );\n      scope.throwIfCanceled();\n\n      // find the index of the bubblegum instruction\n      const relevantIndex =\n        txInfo!.transaction.message.compiledInstructions.findIndex(\n          (instruction) => {\n            return (\n              txInfo?.transaction.message.staticAccountKeys[\n                instruction.programIdIndex\n              ].toBase58() === 'BGUMAp9Gq7iTEuizy4pqaxsTyUCBK68MDfK752saRPUY'\n            );\n          }\n        );\n\n      // locate the no-op inner instructions called via cpi from bubblegum\n      const relevantInnerIxs = txInfo!.meta?.innerInstructions?.[\n        relevantIndex\n      ].instructions.filter((instruction) => {\n        return (\n          txInfo?.transaction.message.staticAccountKeys[\n            instruction.programIdIndex\n          ].toBase58() === 'noopb9bkMVfRPU8AsbpTUg8AQkHtKwMYZiFUjNRtMmV'\n        );\n      });\n\n      // when no valid noop instructions are found, throw an error\n      if (!relevantInnerIxs || relevantInnerIxs.length == 0)\n        throw Error('Unable to locate valid noop instructions');\n\n      // locate the asset index by attempting to locate and parse the correct `relevantInnerIx`\n      let assetIndex: number | undefined = undefined;\n      // note: the `assetIndex` is expected to be at position `1`, and normally expect only 2 `relevantInnerIx`\n      for (let i = relevantInnerIxs.length - 1; i > 0; i--) {\n        try {\n          const changeLogEvent = deserializeChangeLogEventV1(\n            Buffer.from(base58.decode(relevantInnerIxs[i]?.data!))\n          );\n\n          // extract a successful changelog index\n          assetIndex = changeLogEvent?.index;\n        } catch (__) {\n          // do nothing, invalid data is handled just after the for loop\n        }\n      }\n\n      // when no `assetIndex` was found, throw an error\n      if (typeof assetIndex == 'undefined')\n        throw Error('Unable to locate the newly minted assetId ');\n\n      const assetId = await getLeafAssetId(\n        operation.input.tree,\n        new BN(assetIndex)\n      );\n\n      const nft = await metaplex.nfts().findByAssetId(\n        {\n          assetId,\n        },\n        scope\n      );\n      scope.throwIfCanceled();\n\n      assertNft(nft);\n\n      return {\n        ...output,\n        nft,\n        /**\n         * the assetId is impossible to know before the compressed nft is minted\n         * all these addresses are derived from, or are, the `assetId`\n         */\n        mintAddress: assetId,\n        tokenAddress: assetId,\n        metadataAddress: nft.metadataAddress,\n        masterEditionAddress: nft.edition.address,\n      };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateCompressedNftBuilderParams = Omit<\n  CreateCompressedNftInput,\n  'confirmOptions' | 'tokenAddress' | 'metadataAddress' | 'masterEditionAddress'\n> & {\n  /**\n   * Whether or not the provided token account already exists.\n   * If `false`, we'll add another instruction to create it.\n   *\n   * @defaultValue `true`\n   */\n  tokenExists?: boolean;\n\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the metadata account. */\n  createMetadataInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateCompressedNftBuilderContext = Omit<\n  CreateCompressedNftOutput,\n  'response' | 'nft'\n>;\n\n/**\n * Creates a new compressed NFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .createCompressedNft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-nft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *     tree: merkleTreeAccount\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createCompressedNftBuilder = async (\n  metaplex: Metaplex,\n  params: CreateCompressedNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateCompressedNftBuilderContext>> => {\n  const { payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { updateAuthority = metaplex.identity(), tree } = params;\n\n  const creatorsInput: CreatorInput[] = params.creators ?? [\n    {\n      address: updateAuthority.publicKey,\n      authority: updateAuthority,\n      share: 100,\n    },\n  ];\n  const creators: Option<Creator[]> =\n    creatorsInput.length > 0\n      ? creatorsInput.map((creator) => ({\n          ...creator,\n          verified: creator.address.equals(updateAuthority.publicKey),\n        }))\n      : null;\n\n  // Likely that this information can only be derived after the mint\n  // const verifyAdditionalCreatorInstructions = creatorsInput\n  //   .filter((creator) => {\n  //     return (\n  //       !!creator.authority &&\n  //       !creator.address.equals(updateAuthority.publicKey)\n  //     );\n  //   })\n  //   .map((creator) => {\n  //     return metaplex.nfts().builders().verifyCreator(\n  //       {\n  //         mintAddress,\n  //         creator: creator.authority,\n  //       },\n  //       { programs, payer }\n  //     );\n  //   });\n\n  return (\n    TransactionBuilder.make<CreateCompressedNftBuilderContext>()\n      .setFeePayer(payer)\n\n      // Verify additional creators.\n      // TODO(jon): Add the creator verification instructions\n      // .add(...verifyAdditionalCreatorInstructions)\n\n      // Verify collection.\n      .when(!!params.collection && !!params.collectionAuthority, (builder) => {\n        const { collection, collectionAuthority } = params;\n\n        const [collectionMetadataAddress] = PublicKey.findProgramAddressSync(\n          [\n            Buffer.from('metadata', 'utf8'),\n            TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n            (collection as PublicKey).toBuffer(),\n          ],\n          TOKEN_METADATA_PROGRAM_ID\n        );\n\n        const [collectionMasterEditionAccount] =\n          PublicKey.findProgramAddressSync(\n            [\n              Buffer.from('metadata', 'utf8'),\n              TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n              (collection as PublicKey).toBuffer(),\n              Buffer.from('edition', 'utf8'),\n            ],\n            TOKEN_METADATA_PROGRAM_ID\n          );\n\n        const [treeAuthority] = PublicKey.findProgramAddressSync(\n          [tree.toBuffer()],\n          BUBBLEGUM_PROGRAM_ID\n        );\n\n        const [bubblegumPDA] = PublicKey.findProgramAddressSync(\n          [Buffer.from('collection_cpi', 'utf8')],\n          BUBBLEGUM_PROGRAM_ID\n        );\n\n        return builder.add({\n          instruction:\n            // TODO(jon): We should be able to infer some of these in an intermediary SDK\n            createMintToCollectionV1Instruction(\n              {\n                payer: payer.publicKey,\n\n                merkleTree: tree,\n                treeAuthority,\n                // TODO(jon): Replace this delegate\n                treeDelegate: payer.publicKey,\n\n                // TODO(jon): This should respect the configured owner\n                leafOwner: payer.publicKey,\n                leafDelegate: payer.publicKey,\n\n                collectionMetadata: collectionMetadataAddress,\n                collectionMint: collection as PublicKey,\n                collectionAuthority: (collectionAuthority as Signer).publicKey,\n                // TODO(jon): This should be `collectionMasterEditionAccount`\n                editionAccount: collectionMasterEditionAccount,\n\n                // TODO(jon): Pass along another parameter for this field and default to the BUBBLEGUM_PROGRAM_ID\n                collectionAuthorityRecordPda: BUBBLEGUM_PROGRAM_ID,\n\n                bubblegumSigner: bubblegumPDA,\n\n                // Programs\n                /* Account Compression */\n                compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,\n                // TODO(jon): This argument should be `logWrapperProgram`\n                logWrapper: SPL_NOOP_PROGRAM_ID,\n\n                /* Bubblegum */\n                tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n              },\n              {\n                metadataArgs: {\n                  ...params,\n\n                  symbol: params.symbol ?? '',\n                  creators: creators ?? [],\n\n                  isMutable: !!params.isMutable,\n                  uses: params.uses ?? null,\n\n                  // Only NonFungible tokens are supported.\n                  tokenStandard: TokenStandard.NonFungible,\n                  collection: {\n                    key: collection as PublicKey,\n                    // TODO(jon): Can we verify this here or do we need to send a separate instruction?\n                    verified: false,\n                  },\n\n                  primarySaleHappened: false,\n                  editionNonce: null,\n\n                  tokenProgramVersion: TokenProgramVersion.Original,\n                },\n              }\n            ),\n          signers: [payer, params.collectionAuthority as Signer],\n        });\n      })\n  );\n};\n","import { TokenStandard, Uses } from '@metaplex-foundation/mpl-token-metadata';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { assertNftWithToken, NftWithToken } from '../models';\nimport {\n  createCompressedNftBuilder,\n  CreateCompressedNftBuilderParams,\n} from './createCompressedNft';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  BigNumber,\n  CreatorInput,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  token,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateNftOperation' as const;\n\n/**\n * Creates a new NFT.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .nfts()\n *   .create({\n *     name: 'My NFT',\n *     uri: 'https://example.com/my-nft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createNftOperation = useOperation<CreateNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateNftOperation = Operation<\n  typeof Key,\n  CreateNftInput,\n  CreateNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateNftInput = {\n  /**\n   * The authority that will be able to make changes\n   * to the created NFT.\n   *\n   * This is required as a Signer because creating the master\n   * edition account requires the update authority to sign\n   * the transaction.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  updateAuthority?: Signer;\n\n  /**\n   * The authority that is currently allowed to mint new tokens\n   * for the provided mint account.\n   *\n   * Note that this is only relevant if the `useExistingMint` parameter\n   * if provided.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  mintAuthority?: Signer;\n\n  /**\n   * The address of the new mint account as a Signer.\n   * This is useful if you already have a generated Keypair\n   * for the mint account of the NFT to create.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  useNewMint?: Signer;\n\n  /**\n   * The address of the existing mint account that should be converted\n   * into an NFT. The account at this address should have the right\n   * requirements to become an NFT, e.g. its supply should contains\n   * exactly 1 token.\n   *\n   * @defaultValue Defaults to creating a new mint account with the\n   * right requirements.\n   */\n  useExistingMint?: PublicKey;\n\n  /**\n   * Whether or not we should mint one token for the new NFT.\n   *\n   * @defaultValue `true`\n   */\n  mintTokens?: boolean;\n\n  /**\n   * The owner of the NFT to create.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * The token account linking the mint account and the token owner\n   * together. By default, the associated token account will be used.\n   *\n   * If the provided token account does not exist, it must be passed as\n   * a Signer as we will need to create it before creating the NFT.\n   *\n   * @defaultValue Defaults to creating a new associated token account\n   * using the `mintAddress` and `tokenOwner` parameters.\n   */\n  tokenAddress?: PublicKey | Signer;\n\n  /**\n   * Describes the asset class of the token.\n   * It can be one of the following:\n   * - `TokenStandard.NonFungible`: A traditional NFT (master edition).\n   * - `TokenStandard.FungibleAsset`: A fungible token with metadata that can also have attributes.\n   * - `TokenStandard.Fungible`: A fungible token with simple metadata.\n   * - `TokenStandard.NonFungibleEdition`: A limited edition NFT \"printed\" from a master edition.\n   * - `TokenStandard.ProgrammableNonFungible`: A master edition NFT with programmable configuration.\n   *\n   * @defaultValue `TokenStandard.NonFungible`\n   */\n  tokenStandard?: TokenStandard;\n\n  /** The URI that points to the JSON metadata of the asset. */\n  uri: string;\n\n  /** The on-chain name of the asset, e.g. \"My NFT #123\". */\n  name: string;\n\n  /**\n   * The royalties in percent basis point (i.e. 250 is 2.5%) that\n   * should be paid to the creators on each secondary sale.\n   */\n  sellerFeeBasisPoints: number;\n\n  /**\n   * The on-chain symbol of the asset, stored in the Metadata account.\n   * E.g. \"MYNFT\".\n   *\n   * @defaultValue `\"\"`\n   */\n  symbol?: string;\n\n  /**\n   * {@inheritDoc CreatorInput}\n   * @defaultValue\n   * Defaults to using the provided `updateAuthority` as the only verified creator.\n   * ```ts\n   * [{\n   *   address: updateAuthority.publicKey,\n   *   authority: updateAuthority,\n   *   share: 100,\n   * }]\n   * ```\n   */\n  creators?: CreatorInput[];\n\n  /**\n   * Whether or not the NFT's metadata is mutable.\n   * When set to `false` no one can update the Metadata account,\n   * not even the update authority.\n   *\n   * @defaultValue `true`\n   */\n  isMutable?: boolean;\n\n  /**\n   * Whether or not selling this asset is considered a primary sale.\n   * Once flipped from `false` to `true`, this field is immutable and\n   * all subsequent sales of this asset will be considered secondary.\n   *\n   * @defaultValue `false`\n   */\n  primarySaleHappened?: boolean;\n\n  /**\n   * The maximum supply of printed editions.\n   * When this is `null`, an unlimited amount of editions\n   * can be printed from the original edition.\n   *\n   * @defaultValue `toBigNumber(0)`\n   */\n  maxSupply?: Option<BigNumber>;\n\n  /**\n   * When this field is not `null`, it indicates that the NFT\n   * can be \"used\" by its owner or any approved \"use authorities\".\n   *\n   * @defaultValue `null`\n   */\n  uses?: Option<Uses>;\n\n  /**\n   * Whether the created NFT is a Collection NFT.\n   * When set to `true`, the NFT will be created as a\n   * Sized Collection NFT with an initial size of 0.\n   *\n   * @defaultValue `false`\n   */\n  isCollection?: boolean;\n\n  /**\n   * The Collection NFT that this new NFT belongs to.\n   * When `null`, the created NFT will not be part of a collection.\n   *\n   * @defaultValue `null`\n   */\n  collection?: Option<PublicKey>;\n\n  /**\n   * The collection authority that should sign the created NFT\n   * to prove that it is part of the provided collection.\n   * When `null`, the provided `collection` will not be verified.\n   *\n   * @defaultValue `null`\n   */\n  collectionAuthority?: Option<Signer>;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority\n   * using `metaplex.nfts().approveCollectionAuthority()`.\n   *\n   * @defaultValue `false`\n   */\n  collectionAuthorityIsDelegated?: boolean;\n\n  /**\n   * Whether or not the provided `collection` is a sized collection\n   * and not a legacy collection.\n   *\n   * @defaultValue `true`\n   */\n  collectionIsSized?: boolean;\n\n  /**\n   * The ruleset account that should be used to configure the\n   * programmable NFT.\n   *\n   * This is only relevant for programmable NFTs, i.e. if the\n   * `tokenStandard` is set to `TokenStandard.ProgrammableNonFungible`.\n   *\n   * @defaultValue `null`\n   */\n  ruleSet?: Option<PublicKey>;\n\n  /**\n   * The Merkle tree used to store the NFT\n   */\n  tree?: Option<PublicKey>;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created NFT and its associated token. */\n  nft: NftWithToken;\n\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The address of the metadata account. */\n  metadataAddress: PublicKey;\n\n  /** The address of the master edition account. */\n  masterEditionAddress: PublicKey;\n\n  /** The address of the token account. */\n  tokenAddress: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createNftOperationHandler: OperationHandler<CreateNftOperation> = {\n  handle: async (\n    operation: CreateNftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ) => {\n    const {\n      useNewMint = Keypair.generate(),\n      useExistingMint,\n      tokenOwner = metaplex.identity().publicKey,\n      tokenAddress: tokenSigner,\n    } = operation.input;\n\n    const mintAddress = useExistingMint ?? useNewMint.publicKey;\n    const tokenAddress = tokenSigner\n      ? toPublicKey(tokenSigner)\n      : metaplex.tokens().pdas().associatedTokenAccount({\n          mint: mintAddress,\n          owner: tokenOwner,\n          programs: scope.programs,\n        });\n    const tokenAccount = await metaplex.rpc().getAccount(tokenAddress);\n    const tokenExists = tokenAccount.exists;\n\n    const builder = await createNftBuilder(\n      metaplex,\n      {\n        ...operation.input,\n        useNewMint,\n        tokenOwner,\n        tokenExists,\n      },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n      metaplex,\n      scope.confirmOptions\n    );\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n\n    const nft = await metaplex.nfts().findByMint(\n      {\n        mintAddress: output.mintAddress,\n        tokenAddress: output.tokenAddress,\n      },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    assertNftWithToken(nft);\n    return { ...output, nft };\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateNftBuilderParams = Omit<CreateNftInput, 'confirmOptions'> & {\n  /**\n   * Whether or not the provided token account already exists.\n   * If `false`, we'll add another instruction to create it.\n   *\n   * @defaultValue `true`\n   */\n  tokenExists?: boolean;\n\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the metadata account. */\n  createMetadataInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the master edition account. */\n  createMasterEditionInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateNftBuilderContext = Omit<CreateNftOutput, 'response' | 'nft'>;\n\n/**\n * Creates a new NFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .create({\n *     name: 'My NFT',\n *     uri: 'https://example.com/my-nft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createNftBuilder = async (\n  metaplex: Metaplex,\n  params: CreateNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateNftBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    useNewMint = Keypair.generate(),\n    updateAuthority = metaplex.identity(),\n    mintAuthority = metaplex.identity(),\n    tokenOwner = metaplex.identity().publicKey,\n    mintTokens = true,\n    tree,\n  } = params;\n\n  if (tree) {\n    // @ts-ignore\n    return createCompressedNftBuilder(\n      metaplex,\n      params as CreateCompressedNftBuilderParams,\n      options\n    );\n  }\n\n  const sftBuilder = await metaplex\n    .nfts()\n    .builders()\n    .createSft(\n      {\n        ...params,\n        tokenStandard: params.tokenStandard ?? TokenStandard.NonFungible,\n        updateAuthority,\n        mintAuthority,\n        useNewMint,\n        tokenOwner,\n        tokenAmount: mintTokens ? token(1) : undefined,\n        decimals: 0,\n      },\n      { programs, payer }\n    );\n\n  const { mintAddress, metadataAddress, tokenAddress } =\n    sftBuilder.getContext();\n  const masterEditionAddress = metaplex.nfts().pdas().masterEdition({\n    mint: mintAddress,\n    programs,\n  });\n\n  return (\n    TransactionBuilder.make<CreateNftBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        mintAddress,\n        metadataAddress,\n        masterEditionAddress,\n        tokenAddress: tokenAddress as PublicKey,\n      })\n\n      // Create the mint, the token and the metadata.\n      .add(sftBuilder)\n  );\n};\n","import {\n  ProgrammableConfig,\n  TokenStandard,\n  UseMethod,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey } from '@solana/web3.js';\nimport { MetadataAccount } from '../accounts';\nimport { JsonMetadata } from './JsonMetadata';\nimport { assert, Option, removeEmptyChars } from '@/utils';\nimport {\n  BigNumber,\n  Creator,\n  Pda,\n  toBigNumber,\n  ReadApiCompressionMetadata,\n} from '@/types';\n\n/** @group Models */\nexport type Metadata<Json extends object = JsonMetadata> = {\n  /** A model identifier to distinguish models in the SDK. */\n  readonly model: 'metadata';\n\n  /** The address of the Metadata account. */\n  readonly address: Pda;\n\n  /** The address of the Mint account. */\n  readonly mintAddress: PublicKey;\n\n  /**\n   * The address of the authority that is allowed\n   * to make changes to the Metadata account.\n   */\n  readonly updateAuthorityAddress: PublicKey;\n\n  /** The JSON metadata associated with the metadata account. */\n  readonly json: Option<Json>;\n\n  /**\n   * Whether or not the JSON metadata was loaded in the first place.\n   * When this is `false`, the `json` property is should be ignored.\n   */\n  readonly jsonLoaded: boolean;\n\n  /**\n   * The on-chain name of the asset, stored in the Metadata account.\n   * E.g. \"My NFT #123\"\n   */\n  readonly name: string;\n\n  /**\n   * The on-chain symbol of the asset, stored in the Metadata account.\n   * E.g. \"MYNFT\"\n   */\n  readonly symbol: string;\n\n  /**\n   * The URI that points to the JSON metadata of the asset.\n   * This URI is used to load the `json` property of this object.\n   */\n  readonly uri: string;\n\n  /**\n   * Whether or not the asset is mutable.\n   * When set to `false` no one can update the Metadata account,\n   * not even the update authority.\n   */\n  readonly isMutable: boolean;\n\n  /**\n   * Whether or not the asset has already been sold to its first buyer.\n   * When set to `false`, all royalties should be paid to the creators.\n   * When set to `true`, royalties should be calculate as usual.\n   */\n  readonly primarySaleHappened: boolean;\n\n  /**\n   * The royalties in percent basis point (i.e. 250 is 2.5%) that\n   * should be paid to the creators on each secondary sale.\n   */\n  readonly sellerFeeBasisPoints: number;\n\n  /** Stores the bump of the edition PDA. */\n  readonly editionNonce: Option<number>;\n\n  /**\n   * The creators of the asset.\n   * Each object within the array contains the address,\n   * the shares in percent (i.e. 5 is 5%) and whether or not the\n   * creator is verified (i.e. they signed the asset).\n   */\n  readonly creators: Creator[];\n\n  /**\n   * This enum indicates which type of asset we are dealing with.\n   * It can be an NFT, a limited edition of an original NFT,\n   * a fungible asset (i.e. it has zero decimals)\n   * or a fungible token (i.e. it has more than zero decimals).\n   */\n  readonly tokenStandard: Option<TokenStandard>;\n\n  /**\n   * The parent collection the asset belongs to.\n   */\n  readonly collection: Option<{\n    /** The mint address of the collection asset. */\n    address: PublicKey;\n\n    /**\n     * Whether a collection authority signed this asset to\n     * ensure it is part of the collection.\n     * If `verified` is `false`, you should not trust\n     * the asset as being part of the collection.\n     */\n    verified: boolean;\n  }>;\n\n  /**\n   * When this field is not `null`, it indicates that\n   * the asset is a collection. Every time an asset is\n   * verified/unverified as part of this collection,\n   * the `size` field inside this object will be updated accordingly.\n   */\n  readonly collectionDetails: Option<{\n    /** The collection details version. For now, there's only one version. */\n    version: 'V1';\n\n    /** The size of the collection, automatically kept up-to-date by the program. */\n    size: BigNumber;\n  }>;\n\n  /**\n   * When this field is not `null`, it indicates that the asset\n   * can be \"used\" by its owner or any approved \"use authorities\".\n   */\n  readonly uses: Option<{\n    /** An enum selecting a strategy for using the asset. */\n    useMethod: UseMethod;\n\n    /** The amount of remaining uses. */\n    remaining: BigNumber;\n\n    /** The total amount of uses that was initially allowed. */\n    total: BigNumber;\n  }>;\n\n  /** Programmable configuration for the asset. */\n  readonly programmableConfig: Option<ProgrammableConfig>;\n\n  /* Compression metadata only provided via the ReadApi */\n  readonly compression?: ReadApiCompressionMetadata;\n};\n\n/** @group Model Helpers */\nexport const isMetadata = (value: any): value is Metadata =>\n  typeof value === 'object' && value.model === 'metadata';\n\n/** @group Model Helpers */\nexport function assertMetadata(value: any): asserts value is Metadata {\n  assert(isMetadata(value), `Expected Metadata model`);\n}\n\n/** @group Model Helpers */\nexport const toMetadata = (\n  account: MetadataAccount,\n  json?: Option<JsonMetadata>\n): Metadata => ({\n  model: 'metadata',\n  address: Pda.find(account.owner, [\n    Buffer.from('metadata', 'utf8'),\n    account.owner.toBuffer(),\n    account.data.mint.toBuffer(),\n  ]),\n  mintAddress: account.data.mint,\n  updateAuthorityAddress: account.data.updateAuthority,\n  json: json ?? null,\n  jsonLoaded: json !== undefined,\n  name: removeEmptyChars(account.data.data.name),\n  symbol: removeEmptyChars(account.data.data.symbol),\n  uri: removeEmptyChars(account.data.data.uri),\n  isMutable: account.data.isMutable,\n  primarySaleHappened: account.data.primarySaleHappened,\n  sellerFeeBasisPoints: account.data.data.sellerFeeBasisPoints,\n  editionNonce: account.data.editionNonce,\n  creators: account.data.data.creators ?? [],\n  tokenStandard: account.data.tokenStandard,\n  collection: account.data.collection\n    ? {\n        ...account.data.collection,\n        address: account.data.collection.key,\n      }\n    : null,\n  collectionDetails: account.data.collectionDetails\n    ? {\n        version: account.data.collectionDetails.__kind,\n        size: toBigNumber(account.data.collectionDetails.size),\n      }\n    : null,\n  uses: account.data.uses\n    ? {\n        ...account.data.uses,\n        remaining: toBigNumber(account.data.uses.remaining),\n        total: toBigNumber(account.data.uses.total),\n      }\n    : null,\n  programmableConfig: account.data.programmableConfig,\n});\n\nexport const isNonFungible = (nftOrSft: {\n  tokenStandard: Option<TokenStandard>;\n}): boolean =>\n  nftOrSft.tokenStandard === null ||\n  nftOrSft.tokenStandard === TokenStandard.NonFungible ||\n  nftOrSft.tokenStandard === TokenStandard.NonFungibleEdition ||\n  nftOrSft.tokenStandard === TokenStandard.ProgrammableNonFungible;\n\nexport const isProgrammable = (nftOrSft: {\n  tokenStandard: Option<TokenStandard>;\n}): boolean => nftOrSft.tokenStandard === TokenStandard.ProgrammableNonFungible;\n","import {\n  createCreateInstruction,\n  PrintSupply,\n  TokenStandard,\n  Uses,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport {\n  Keypair,\n  PublicKey,\n  SYSVAR_INSTRUCTIONS_PUBKEY,\n} from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { assertSft, isNonFungible, Sft, SftWithToken } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  BigNumber,\n  Creator,\n  CreatorInput,\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateSftOperation' as const;\n\n/**\n * Creates a new SFT.\n *\n * ```ts\n * const { sft } = await metaplex\n *   .nfts()\n *   .createSft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-sft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createSftOperation = useOperation<CreateSftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateSftOperation = Operation<\n  typeof Key,\n  CreateSftInput,\n  CreateSftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateSftInput = {\n  /**\n   * The authority that will be able to make changes\n   * to the created SFT.\n   *\n   * This is required as a Signer because creating the\n   * metadata account requires the update authority to be part\n   * of the creators array as a verified creator.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  updateAuthority?: Signer;\n\n  /**\n   * The authority allowed to mint new tokens for the mint account\n   * that is either explicitly provided or about to be created.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  mintAuthority?: Signer;\n\n  /**\n   * The address of the new mint account as a Signer.\n   * This is useful if you already have a generated Keypair\n   * for the mint account of the SFT to create.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  useNewMint?: Signer;\n\n  /**\n   * The address of the existing mint account that should be converted\n   * into an SFT. The account at this address should have the right\n   * requirements to become an SFT, e.g. it shouldn't already have\n   * a metadata account associated with it.\n   *\n   * @defaultValue Defaults to creating a new mint account with the\n   * right requirements.\n   */\n  useExistingMint?: PublicKey;\n\n  /**\n   * The owner of a token account associated with the SFT to create.\n   *\n   * This is completely optional as creating an SFT does not require\n   * the existence of a token account. When provided, an associated\n   * token account will be created from the given owner.\n   *\n   * You may alternatively pass the `tokenAddress` parameter instead.\n   *\n   * @defaultValue Defaults to not creating and/or minting\n   * any token account.\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * An explicit token account associated with the SFT to create.\n   *\n   * This is completely optional as creating an SFT does not require\n   * the existence of a token account.\n   *\n   * When provided, the token account will be created if and only\n   * if no account exists at the given address. When that's the case,\n   * the `tokenAddress` must be provided as a Signer as we're creating\n   * and initializing the account at this address.\n   *\n   * You may alternatively pass the `tokenOwner` parameter instead.\n   *\n   * @defaultValue Defaults to not creating and/or minting\n   * any token account.\n   */\n  tokenAddress?: PublicKey | Signer;\n\n  /**\n   * The amount of tokens to mint to the token account initially\n   * if a token account is created.\n   *\n   * This is only relevant if either the `tokenOwner` or `tokenAddress`\n   * is provided.\n   *\n   * @defaultValue Defaults to not minting any tokens.\n   */\n  tokenAmount?: SplTokenAmount;\n\n  /**\n   * The number of decimal points used to define token amounts.\n   *\n   * @defaultValue `0`\n   */\n  decimals?: number;\n\n  /**\n   * Describes the asset class of the token.\n   * It can be one of the following:\n   * - `TokenStandard.NonFungible`: A traditional NFT (master edition).\n   * - `TokenStandard.FungibleAsset`: A fungible token with metadata that can also have attrributes.\n   * - `TokenStandard.Fungible`: A fungible token with simple metadata.\n   * - `TokenStandard.NonFungibleEdition`: A limited edition NFT \"printed\" from a master edition.\n   * - `TokenStandard.ProgrammableNonFungible`: A master edition NFT with programmable configuration.\n   *\n   * @defaultValue `TokenStandard.FungibleAsset`\n   */\n  tokenStandard?: TokenStandard;\n\n  /** The URI that points to the JSON metadata of the asset. */\n  uri: string;\n\n  /** The on-chain name of the asset, e.g. \"My SFT\". */\n  name: string;\n\n  /**\n   * The royalties in percent basis point (i.e. 250 is 2.5%) that\n   * should be paid to the creators on each secondary sale.\n   */\n  sellerFeeBasisPoints: number;\n\n  /**\n   * The on-chain symbol of the asset, stored in the Metadata account.\n   * E.g. \"MYSFT\".\n   *\n   * @defaultValue `\"\"`\n   */\n  symbol?: string;\n\n  /**\n   * {@inheritDoc CreatorInput}\n   * @defaultValue\n   * Defaults to using the provided `updateAuthority` as the only verified creator.\n   * ```ts\n   * [{\n   *   address: updateAuthority.publicKey,\n   *   authority: updateAuthority,\n   *   share: 100,\n   * }]\n   * ```\n   */\n  creators?: CreatorInput[];\n\n  /**\n   * Whether or not the SFT's metadata is mutable.\n   * When set to `false` no one can update the Metadata account,\n   * not even the update authority.\n   *\n   * @defaultValue `true`\n   */\n  isMutable?: boolean;\n\n  /**\n   * The maximum supply of printed editions for NFTs.\n   * When this is `null`, an unlimited amount of editions\n   * can be printed from the original edition.\n   *\n   * @defaultValue `toBigNumber(0)`\n   */\n  maxSupply?: Option<BigNumber>;\n\n  /**\n   * Whether or not selling this asset is considered a primary sale.\n   * Once flipped from `false` to `true`, this field is immutable and\n   * all subsequent sales of this asset will be considered secondary.\n   *\n   * @defaultValue `false`\n   */\n  primarySaleHappened?: boolean;\n\n  /**\n   * When this field is not `null`, it indicates that the SFT\n   * can be \"used\" by its owner or any approved \"use authorities\".\n   *\n   * @defaultValue `null`\n   */\n  uses?: Option<Uses>;\n\n  /**\n   * Whether the created SFT is a Collection SFT.\n   * When set to `true`, the SFT will be created as a\n   * Sized Collection SFT with an initial size of 0.\n   *\n   * @defaultValue `false`\n   */\n  isCollection?: boolean;\n\n  /**\n   * The Collection NFT that this new SFT belongs to.\n   * When `null`, the created SFT will not be part of a collection.\n   *\n   * @defaultValue `null`\n   */\n  collection?: Option<PublicKey>;\n\n  /**\n   * The collection authority that should sign the created SFT\n   * to prove that it is part of the provided collection.\n   * When `null`, the provided `collection` will not be verified.\n   *\n   * @defaultValue `null`\n   */\n  collectionAuthority?: Option<Signer>;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority\n   * using `metaplex.nfts().approveCollectionAuthority()`.\n   *\n   * @defaultValue `false`\n   */\n  collectionAuthorityIsDelegated?: boolean;\n\n  /**\n   * Whether or not the provided `collection` is a sized collection\n   * and not a legacy collection.\n   *\n   * @defaultValue `true`\n   */\n  collectionIsSized?: boolean;\n\n  /**\n   * The ruleset account that should be used to configure the\n   * programmable NFT.\n   *\n   * This is only relevant for programmable NFTs, i.e. if the\n   * `tokenStandard` is set to `TokenStandard.ProgrammableNonFungible`.\n   *\n   * @defaultValue `null`\n   */\n  ruleSet?: Option<PublicKey>;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateSftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created SFT and, potentially, its associated token. */\n  sft: Sft | SftWithToken;\n\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The address of the metadata account. */\n  metadataAddress: PublicKey;\n\n  /** The address of the token account if any. */\n  tokenAddress: PublicKey | null;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createSftOperationHandler: OperationHandler<CreateSftOperation> = {\n  handle: async (\n    operation: CreateSftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ) => {\n    const {\n      useNewMint = Keypair.generate(),\n      useExistingMint,\n      tokenOwner,\n      tokenAddress: tokenSigner,\n    } = operation.input;\n\n    const mintAddress = useExistingMint ?? useNewMint.publicKey;\n    const associatedTokenAddress = tokenOwner\n      ? metaplex.tokens().pdas().associatedTokenAccount({\n          mint: mintAddress,\n          owner: tokenOwner,\n          programs: scope.programs,\n        })\n      : null;\n    const tokenAddress = tokenSigner\n      ? toPublicKey(tokenSigner)\n      : associatedTokenAddress;\n\n    let tokenExists: boolean;\n    if (!!useExistingMint && !!tokenAddress) {\n      const tokenAccount = await metaplex.rpc().getAccount(tokenAddress);\n      tokenExists = tokenAccount.exists;\n    } else {\n      tokenExists = false;\n    }\n\n    const builder = await createSftBuilder(\n      metaplex,\n      { ...operation.input, useNewMint, tokenExists },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n      metaplex,\n      scope.confirmOptions\n    );\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n\n    const sft = await metaplex.nfts().findByMint(\n      {\n        mintAddress: output.mintAddress,\n        tokenAddress: output.tokenAddress ?? undefined,\n      },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    assertSft(sft);\n    return { ...output, sft };\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateSftBuilderParams = Omit<CreateSftInput, 'confirmOptions'> & {\n  /**\n   * Whether or not the provided token account already exists.\n   * If `false`, we'll add another instruction to create it.\n   *\n   * @defaultValue `true`\n   */\n  tokenExists?: boolean;\n\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the metadata account. */\n  createInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateSftBuilderContext = Omit<CreateSftOutput, 'response' | 'sft'>;\n\n/**\n * Creates a new SFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .createSft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-sft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createSftBuilder = async (\n  metaplex: Metaplex,\n  params: CreateSftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateSftBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    useNewMint = Keypair.generate(),\n    updateAuthority = metaplex.identity(),\n    mintAuthority = metaplex.identity(),\n    tokenStandard = params.tokenStandard ?? TokenStandard.FungibleAsset,\n  } = params;\n\n  const mintAddress = params.useExistingMint ?? useNewMint.publicKey;\n  const associatedTokenAddress = params.tokenOwner\n    ? metaplex.tokens().pdas().associatedTokenAccount({\n        mint: mintAddress,\n        owner: params.tokenOwner,\n        programs,\n      })\n    : null;\n  const tokenAddress = params.tokenAddress\n    ? toPublicKey(params.tokenAddress)\n    : associatedTokenAddress;\n\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const metadataPda = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const masterEditionPda = metaplex.nfts().pdas().masterEdition({\n    mint: mintAddress,\n    programs,\n  });\n  const creatorsInput: CreatorInput[] = params.creators ?? [\n    {\n      address: updateAuthority.publicKey,\n      authority: updateAuthority,\n      share: 100,\n    },\n  ];\n  const creators: Option<Creator[]> =\n    creatorsInput.length > 0\n      ? creatorsInput.map((creator) => ({\n          ...creator,\n          verified: creator.address.equals(updateAuthority.publicKey),\n        }))\n      : null;\n\n  let printSupply: Option<PrintSupply> = null;\n  if (isNonFungible({ tokenStandard })) {\n    if (params.maxSupply === undefined) {\n      printSupply = { __kind: 'Zero' };\n    } else if (params.maxSupply === null) {\n      printSupply = { __kind: 'Unlimited' };\n    } else {\n      printSupply = { __kind: 'Limited', fields: [params.maxSupply] };\n    }\n  }\n\n  const createInstruction = createCreateInstruction(\n    {\n      metadata: metadataPda,\n      masterEdition: isNonFungible({ tokenStandard })\n        ? masterEditionPda\n        : undefined,\n      mint: mintAddress,\n      authority: mintAuthority.publicKey,\n      payer: payer.publicKey,\n      updateAuthority: updateAuthority.publicKey,\n      systemProgram: systemProgram.address,\n      sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n      splTokenProgram: tokenProgram.address,\n    },\n    {\n      createArgs: {\n        __kind: 'V1' as const,\n        assetData: {\n          name: params.name,\n          symbol: params.symbol ?? '',\n          uri: params.uri,\n          sellerFeeBasisPoints: params.sellerFeeBasisPoints,\n          creators,\n          primarySaleHappened: params.primarySaleHappened ?? false,\n          isMutable: params.isMutable ?? true,\n          tokenStandard,\n          collection: params.collection\n            ? { key: params.collection, verified: false }\n            : null,\n          uses: params.uses ?? null,\n          collectionDetails: params.isCollection\n            ? { __kind: 'V1' as const, size: 0 } // Size ignored by program.\n            : null,\n          ruleSet: params.ruleSet ?? null,\n        },\n        decimals: params.decimals ?? 0,\n        printSupply,\n      },\n    },\n    tokenMetadataProgram.address\n  );\n\n  const createSigners = [payer, mintAuthority, updateAuthority];\n  if (!params.useExistingMint) {\n    createSigners.push(useNewMint);\n    createInstruction.keys[2].isSigner = true;\n  }\n\n  // When the payer is different than the update authority, the latter will\n  // not be marked as a signer and therefore signing as a creator will fail.\n  createInstruction.keys[5].isSigner = true;\n\n  let createNonAtaInstruction: TransactionBuilder | null = null;\n  // Create the token account if it doesn't exist.\n  if (\n    !params.tokenExists &&\n    !!params.tokenAddress &&\n    isSigner(params.tokenAddress)\n  ) {\n    createNonAtaInstruction = await metaplex.tokens().builders().createToken(\n      {\n        mint: mintAddress,\n        owner: params.tokenOwner,\n        token: params.tokenAddress,\n        createAccountInstructionKey: params.createTokenAccountInstructionKey,\n        initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n      },\n      { programs, payer }\n    );\n  }\n\n  // Mint provided amount to the token account.\n  let mintInstruction: TransactionBuilder | null = null;\n  if (tokenAddress && params.tokenAmount) {\n    mintInstruction = metaplex\n      .nfts()\n      .builders()\n      .mint(\n        {\n          nftOrSft: {\n            address: mintAddress,\n            tokenStandard,\n          },\n          authority: isNonFungible({ tokenStandard })\n            ? updateAuthority\n            : mintAuthority,\n          toOwner: params.tokenOwner,\n          toToken: tokenAddress,\n          amount: params.tokenAmount,\n        },\n        { programs, payer }\n      );\n  }\n\n  const verifyAdditionalCreatorInstructions = creatorsInput\n    .filter((creator) => {\n      return (\n        !!creator.authority &&\n        !creator.address.equals(updateAuthority.publicKey)\n      );\n    })\n    .map((creator) => {\n      return metaplex.nfts().builders().verifyCreator(\n        {\n          mintAddress,\n          creator: creator.authority,\n        },\n        { programs, payer }\n      );\n    });\n\n  return (\n    TransactionBuilder.make<CreateSftBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        mintAddress,\n        metadataAddress: metadataPda,\n        tokenAddress,\n      })\n\n      // Create the mint and token accounts before minting 1 token to the owner.\n      // .add(mintAndTokenBuilder)\n\n      // Create metadata/edition accounts.\n      .add({\n        instruction: createInstruction,\n        signers: createSigners,\n        key: params.createInstructionKey ?? 'createMetadata',\n      })\n\n      // Create the non-associated token account if needed.\n      .add(...(createNonAtaInstruction ? [createNonAtaInstruction] : []))\n\n      // Mint provided amount to the token account, if any.\n      .add(...(mintInstruction ? [mintInstruction] : []))\n\n      // Verify additional creators.\n      .add(...verifyAdditionalCreatorInstructions)\n\n      // Verify collection.\n      .when(!!params.collection && !!params.collectionAuthority, (builder) =>\n        builder.add(\n          metaplex\n            .nfts()\n            .builders()\n            .verifyCollection(\n              {\n                mintAddress,\n                collectionMintAddress: params.collection as PublicKey,\n                collectionAuthority: params.collectionAuthority as Signer,\n                isDelegated: params.collectionAuthorityIsDelegated ?? false,\n                isSizedCollection: params.collectionIsSized ?? true,\n              },\n              { payer, programs }\n            )\n        )\n      )\n  );\n};\n","import { Buffer } from 'buffer';\nimport {\n  Edition,\n  Key,\n  MasterEditionV1,\n  MasterEditionV2,\n  Metadata,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport {\n  Account,\n  SolitaType,\n  getAccountParsingAndAssertingFunction,\n  getAccountParsingFunction,\n} from '@/types';\nimport { NotYetImplementedError } from '@/errors';\n\n/** @group Accounts */\nexport type MetadataAccount = Account<Metadata>;\n\n/** @group Account Helpers */\nexport const parseMetadataAccount = getAccountParsingFunction(Metadata);\n\n/** @group Account Helpers */\nexport const toMetadataAccount =\n  getAccountParsingAndAssertingFunction(Metadata);\n\n/** @group Accounts */\nexport type OriginalOrPrintEditionAccountData =\n  | OriginalEditionAccountData\n  | PrintEditionAccountData;\n\n/** @group Accounts */\nexport type OriginalOrPrintEditionAccount =\n  Account<OriginalOrPrintEditionAccountData>;\n\nconst originalOrPrintEditionAccountParser: SolitaType<OriginalOrPrintEditionAccountData> =\n  {\n    name: 'MasterEditionV1 | MasterEditionV2 | Edition',\n    deserialize: (data: Buffer, offset = 0) => {\n      if (data?.[0] === Key.MasterEditionV1) {\n        return MasterEditionV1.deserialize(data, offset);\n      } else if (data?.[0] === Key.MasterEditionV2) {\n        return MasterEditionV2.deserialize(data, offset);\n      }\n      return Edition.deserialize(data, offset);\n    },\n    fromArgs() {\n      throw new NotYetImplementedError();\n    },\n  };\n\n/** @group Account Helpers */\nexport const parseOriginalOrPrintEditionAccount =\n  getAccountParsingFunction<OriginalOrPrintEditionAccountData>(\n    originalOrPrintEditionAccountParser\n  );\n\n/** @group Account Helpers */\nexport const toOriginalOrPrintEditionAccount =\n  getAccountParsingAndAssertingFunction<OriginalOrPrintEditionAccountData>(\n    originalOrPrintEditionAccountParser\n  );\n\n/** @group Account Helpers */\nexport const isOriginalEditionAccount = (\n  account: OriginalOrPrintEditionAccount\n): account is OriginalEditionAccount => {\n  return 'maxSupply' in account.data;\n};\n\n/** @group Account Helpers */\nexport const isPrintEditionAccount = (\n  account: OriginalOrPrintEditionAccount\n): account is PrintEditionAccount => {\n  return !isOriginalEditionAccount(account);\n};\n\n/** @group Accounts */\nexport type OriginalEditionAccountData = MasterEditionV1 | MasterEditionV2;\n\n/** @group Accounts */\nexport type OriginalEditionAccount = Account<OriginalEditionAccountData>;\n\nconst originalEditionAccountParser: SolitaType<OriginalEditionAccountData> = {\n  name: 'MasterEditionV1 | MasterEditionV2',\n  deserialize: (data: Buffer, offset = 0) => {\n    if (data?.[0] === Key.MasterEditionV1) {\n      return MasterEditionV1.deserialize(data, offset);\n    }\n    return MasterEditionV2.deserialize(data, offset);\n  },\n  fromArgs() {\n    throw new NotYetImplementedError();\n  },\n};\n\n/** @group Account Helpers */\nexport const parseOriginalEditionAccount =\n  getAccountParsingFunction<OriginalEditionAccountData>(\n    originalEditionAccountParser\n  );\n\n/** @group Account Helpers */\nexport const toOriginalEditionAccount =\n  getAccountParsingAndAssertingFunction<OriginalEditionAccountData>(\n    originalEditionAccountParser\n  );\n\n/** @group Accounts */\nexport type PrintEditionAccountData = Edition;\n\n/** @group Accounts */\nexport type PrintEditionAccount = Account<PrintEditionAccountData>;\n\n/** @group Account Helpers */\nexport const parsePrintEditionAccount = getAccountParsingFunction(Edition);\n\n/** @group Account Helpers */\nexport const toPrintEditionAccount =\n  getAccountParsingAndAssertingFunction(Edition);\n","import { PublicKey } from '@solana/web3.js';\nimport {\n  isOriginalEditionAccount,\n  OriginalEditionAccount,\n  OriginalOrPrintEditionAccount,\n  PrintEditionAccount,\n} from '../accounts';\nimport { BigNumber, toBigNumber, toOptionBigNumber } from '@/types';\nimport { assert, Option } from '@/utils';\n\n/** @group Models */\nexport type NftEdition = NftOriginalEdition | NftPrintEdition;\n\n/** @group Model Helpers */\nexport const isNftEdition = (value: any): value is NftEdition =>\n  typeof value === 'object' && value.model === 'nftEdition';\n\n/** @group Model Helpers */\nexport function assertNftEdition(value: any): asserts value is NftEdition {\n  assert(isNftEdition(value), `Expected NftEdition model`);\n}\n\n/** @group Model Helpers */\nexport const toNftEdition = (\n  account: OriginalOrPrintEditionAccount\n): NftEdition =>\n  isOriginalEditionAccount(account)\n    ? toNftOriginalEdition(account)\n    : toNftPrintEdition(account as PrintEditionAccount);\n\n/** @group Models */\nexport type NftOriginalEdition = {\n  /** A model identifier to distinguish models in the SDK. */\n  readonly model: 'nftEdition';\n\n  /**\n   * Whether or not this is an original edition.\n   * This field helps distinguish between the `NftOriginalEdition`\n   * and the `NftPrintEdition` models.\n   */\n  readonly isOriginal: true;\n\n  /** The address of the edition account. */\n  readonly address: PublicKey;\n\n  /** The current supply of printed editions. */\n  readonly supply: BigNumber;\n\n  /**\n   * The maximum supply of printed editions.\n   * When this is `null`, an unlimited amount of editions\n   * can be printed from the original edition.\n   */\n  readonly maxSupply: Option<BigNumber>;\n};\n\n/** @group Model Helpers */\nexport const isNftOriginalEdition = (value: any): value is NftOriginalEdition =>\n  isNftEdition(value) && value.isOriginal;\n\n/** @group Model Helpers */\nexport function assertNftOriginalEdition(\n  value: any\n): asserts value is NftOriginalEdition {\n  assert(isNftOriginalEdition(value), `Expected NftOriginalEdition model`);\n}\n\n/** @group Model Helpers */\nexport const toNftOriginalEdition = (\n  account: OriginalEditionAccount\n): NftOriginalEdition => ({\n  model: 'nftEdition',\n  isOriginal: true,\n  address: account.publicKey,\n  supply: toBigNumber(account.data.supply),\n  maxSupply: toOptionBigNumber(account.data.maxSupply),\n});\n\n/** @group Models */\nexport type NftPrintEdition = {\n  /** A model identifier to distinguish models in the SDK. */\n  readonly model: 'nftEdition';\n\n  /**\n   * Whether or not this is an original edition.\n   * This field helps distinguish between the `NftOriginalEdition`\n   * and the `NftPrintEdition` models.\n   */\n  readonly isOriginal: false;\n\n  /** The address of the edition account. */\n  readonly address: PublicKey;\n\n  /** The address of the original edition account this was printed from. */\n  readonly parent: PublicKey;\n\n  /**\n   * The number of this printed edition.\n   *\n   * For instance, `1` means this was the very first edition printed\n   * from the original edition. This is a key difference between\n   * printed editions and SFTs as SFTs do not keep track of any\n   * ordering.\n   */\n  readonly number: BigNumber;\n};\n\n/** @group Model Helpers */\nexport const isNftPrintEdition = (value: any): value is NftPrintEdition =>\n  isNftEdition(value) && !value.isOriginal;\n\n/** @group Model Helpers */\nexport function assertNftPrintEdition(\n  value: any\n): asserts value is NftPrintEdition {\n  assert(isNftPrintEdition(value), `Expected NftPrintEdition model`);\n}\n\n/** @group Model Helpers */\nexport const toNftPrintEdition = (\n  account: PrintEditionAccount\n): NftPrintEdition => ({\n  model: 'nftEdition',\n  isOriginal: false,\n  address: account.publicKey,\n  parent: account.data.parent,\n  number: toBigNumber(account.data.edition),\n});\n","import { createMintNewEditionFromMasterEditionViaTokenInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { toOriginalEditionAccount } from '../accounts';\nimport {\n  assertNftWithToken,\n  NftWithToken,\n  toNftOriginalEdition,\n} from '../models';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  BigNumber,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  toBigNumber,\n  token,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'PrintNewEditionOperation' as const;\n\n/**\n * Prints a new edition from an original NFT.\n *\n * ```ts\n * const { nft } = await metaplex\n *   .nfts()\n *   .printNewEdition({ originalMint };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const printNewEditionOperation =\n  useOperation<PrintNewEditionOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type PrintNewEditionOperation = Operation<\n  typeof Key,\n  PrintNewEditionInput,\n  PrintNewEditionOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type PrintNewEditionInput = {\n  /** The address of the original NFT. */\n  originalMint: PublicKey;\n\n  /**\n   * The owner of the original NFT as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  originalTokenAccountOwner?: Signer;\n\n  /**\n   * The address of the original NFT's token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `originalMint` and `originalTokenAccountOwner` parameters.\n   */\n  originalTokenAccount?: PublicKey;\n\n  /**\n   * The address of the new mint account as a Signer.\n   * This is useful if you already have a generated Keypair\n   * for the mint account of the Print NFT to create.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  newMint?: Signer;\n\n  /**\n   * The update authority of the new printed NFT.\n   *\n   * Depending on your use-case, you might want to change that to\n   * the `updateAuthority` of the original NFT.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  newUpdateAuthority?: PublicKey;\n\n  /**\n   * The owner of the new printed NFT.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  newOwner?: PublicKey;\n\n  /**\n   * The address of the new printed NFT's token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `originalMint` and `newOwner` parameters.\n   */\n  newTokenAccount?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type PrintNewEditionOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created NFT and its associated token. */\n  nft: NftWithToken;\n\n  /** The created mint account as a Signer. */\n  mintSigner: Signer;\n\n  /** The address of the metadata account. */\n  metadataAddress: PublicKey;\n\n  /** The address of the edition account. */\n  editionAddress: PublicKey;\n\n  /** The address of the token account. */\n  tokenAddress: PublicKey;\n\n  /** The new supply of the original NFT. */\n  updatedSupply: BigNumber;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const printNewEditionOperationHandler: OperationHandler<PrintNewEditionOperation> =\n  {\n    handle: async (\n      operation: PrintNewEditionOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ) => {\n      const originalEditionAccount = await metaplex.rpc().getAccount(\n        metaplex.nfts().pdas().masterEdition({\n          mint: operation.input.originalMint,\n          programs: scope.programs,\n        })\n      );\n      scope.throwIfCanceled();\n\n      const originalEdition = toNftOriginalEdition(\n        toOriginalEditionAccount(originalEditionAccount)\n      );\n      const builder = await printNewEditionBuilder(\n        metaplex,\n        { ...operation.input, originalSupply: originalEdition.supply },\n        scope\n      );\n      scope.throwIfCanceled();\n\n      const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n        metaplex,\n        scope.confirmOptions\n      );\n      const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n      scope.throwIfCanceled();\n\n      const nft = await metaplex.nfts().findByMint(\n        {\n          mintAddress: output.mintSigner.publicKey,\n          tokenAddress: output.tokenAddress,\n        },\n        scope\n      );\n      scope.throwIfCanceled();\n\n      assertNftWithToken(nft);\n      return { ...output, nft };\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type PrintNewEditionBuilderParams = Omit<\n  PrintNewEditionInput,\n  'confirmOptions'\n> & {\n  /** The current supply of the original edition. */\n  originalSupply: BigNumber;\n\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that prints the new edition. */\n  printNewEditionInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type PrintNewEditionBuilderContext = Omit<\n  PrintNewEditionOutput,\n  'response' | 'nft'\n>;\n\n/**\n * Prints a new edition from an original NFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .printNewEdition({ originalMint });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const printNewEditionBuilder = async (\n  metaplex: Metaplex,\n  params: PrintNewEditionBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<PrintNewEditionBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    originalMint,\n    newMint = Keypair.generate(),\n    newUpdateAuthority = metaplex.identity().publicKey,\n    newOwner = metaplex.identity().publicKey,\n    newTokenAccount,\n    printNewEditionInstructionKey = 'printNewEdition',\n  } = params;\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  // Original NFT.\n  const originalMetadataAddress = metaplex.nfts().pdas().metadata({\n    mint: originalMint,\n    programs,\n  });\n  const originalEditionAddress = metaplex.nfts().pdas().masterEdition({\n    mint: originalMint,\n    programs,\n  });\n  const edition = toBigNumber(params.originalSupply.addn(1));\n  const originalEditionMarkPda = metaplex.nfts().pdas().editionMarker({\n    mint: originalMint,\n    edition,\n    programs,\n  });\n\n  // New NFT.\n  const newMintAuthority = Keypair.generate(); // Will be overwritten by edition PDA.\n  const newMetadataAddress = metaplex.nfts().pdas().metadata({\n    mint: newMint.publicKey,\n    programs,\n  });\n  const newEditionAddress = metaplex.nfts().pdas().edition({\n    mint: newMint.publicKey,\n    programs,\n  });\n  const sharedAccounts = {\n    newMetadata: newMetadataAddress,\n    newEdition: newEditionAddress,\n    masterEdition: originalEditionAddress,\n    newMint: newMint.publicKey,\n    editionMarkPda: originalEditionMarkPda,\n    newMintAuthority: newMintAuthority.publicKey,\n    payer: payer.publicKey,\n    newMetadataUpdateAuthority: newUpdateAuthority,\n    metadata: originalMetadataAddress,\n  };\n\n  const tokenWithMintBuilder = await metaplex\n    .tokens()\n    .builders()\n    .createTokenWithMint(\n      {\n        decimals: 0,\n        initialSupply: token(1),\n        mint: newMint,\n        mintAuthority: newMintAuthority,\n        freezeAuthority: newMintAuthority.publicKey,\n        owner: newOwner,\n        token: newTokenAccount,\n        createMintAccountInstructionKey: params.createMintAccountInstructionKey,\n        initializeMintInstructionKey: params.initializeMintInstructionKey,\n        createAssociatedTokenAccountInstructionKey:\n          params.createAssociatedTokenAccountInstructionKey,\n        createTokenAccountInstructionKey:\n          params.createTokenAccountInstructionKey,\n        initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n        mintTokensInstructionKey: params.mintTokensInstructionKey,\n      },\n      { payer, programs }\n    );\n\n  const { tokenAddress } = tokenWithMintBuilder.getContext();\n  const originalTokenAccountOwner =\n    params.originalTokenAccountOwner ?? metaplex.identity();\n  const originalTokenAccount =\n    params.originalTokenAccount ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: originalMint,\n      owner: originalTokenAccountOwner.publicKey,\n      programs,\n    });\n\n  return (\n    TransactionBuilder.make<PrintNewEditionBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        mintSigner: newMint,\n        metadataAddress: newMetadataAddress,\n        editionAddress: newEditionAddress,\n        tokenAddress,\n        updatedSupply: edition,\n      })\n\n      // Create the mint and token accounts before minting 1 token to the owner.\n      .add(tokenWithMintBuilder)\n\n      // Mint new edition.\n      .add({\n        instruction: createMintNewEditionFromMasterEditionViaTokenInstruction(\n          {\n            ...sharedAccounts,\n            tokenAccountOwner: originalTokenAccountOwner.publicKey,\n            tokenAccount: originalTokenAccount,\n          },\n          { mintNewEditionFromMasterEditionViaTokenArgs: { edition } },\n          tokenMetadataProgram.address\n        ),\n        signers: [newMint, newMintAuthority, payer, originalTokenAccountOwner],\n        key: printNewEditionInstructionKey,\n      })\n  );\n};\n","import { DelegateArgs } from '@metaplex-foundation/mpl-token-metadata';\nimport { MetadataDelegateType, TokenDelegateType } from './DelegateType';\nimport { Metaplex } from '@/index';\nimport { isSigner, Program, PublicKey, Signer } from '@/types';\n\ntype SplitTypeAndData<\n  T extends { __kind: any },\n  U extends T['__kind'] = any\n> = T extends {\n  __kind: U;\n}\n  ? { type: T['__kind']; data?: Omit<T, '__kind' | 'authorizationData'> }\n  : never;\n\nexport type MetadataDelegateInputWithData<\n  T extends PublicKey | Signer = PublicKey\n> = {\n  delegate: T;\n  updateAuthority: PublicKey;\n} & SplitTypeAndData<DelegateArgs, MetadataDelegateType>;\n\nexport type TokenDelegateInputWithData<\n  T extends PublicKey | Signer = PublicKey\n> = {\n  delegate: T;\n  owner: PublicKey;\n  token?: PublicKey;\n} & SplitTypeAndData<DelegateArgs, TokenDelegateType>;\n\nexport type MetadataDelegateInput<T extends PublicKey | Signer = PublicKey> =\n  Omit<MetadataDelegateInputWithData<T>, 'data'>;\n\nexport type TokenDelegateInput<T extends PublicKey | Signer = PublicKey> = Omit<\n  TokenDelegateInputWithData<T>,\n  'data'\n>;\n\nexport type DelegateInputSigner = DelegateInput<Signer>;\nexport type DelegateInput<T extends PublicKey | Signer = PublicKey> =\n  | MetadataDelegateInput<T>\n  | TokenDelegateInput<T>;\n\nexport type DelegateInputWithDataSigner = DelegateInputWithData<Signer>;\nexport type DelegateInputWithData<T extends PublicKey | Signer = PublicKey> =\n  | MetadataDelegateInputWithData<T>\n  | TokenDelegateInputWithData<T>;\n\nexport const parseTokenMetadataDelegateInput = <\n  T extends PublicKey | Signer = PublicKey\n>(\n  metaplex: Metaplex,\n  mint: PublicKey,\n  input: DelegateInput<T>,\n  programs?: Program[]\n): {\n  delegate: T;\n  approver: PublicKey;\n  delegateRecord: PublicKey;\n  tokenAccount?: PublicKey;\n  isTokenDelegate: boolean;\n} => {\n  if ('updateAuthority' in input) {\n    return {\n      isTokenDelegate: false,\n      delegate: input.delegate,\n      approver: input.updateAuthority,\n      delegateRecord: metaplex\n        .nfts()\n        .pdas()\n        .metadataDelegateRecord({\n          mint,\n          type: input.type,\n          updateAuthority: input.updateAuthority,\n          delegate: isSigner(input.delegate)\n            ? input.delegate.publicKey\n            : input.delegate,\n          programs,\n        }),\n    };\n  }\n\n  const tokenAccount =\n    input.token ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint,\n      owner: input.owner,\n      programs,\n    });\n  return {\n    isTokenDelegate: true,\n    delegate: input.delegate,\n    approver: input.owner,\n    delegateRecord: metaplex.nfts().pdas().tokenRecord({\n      mint,\n      token: tokenAccount,\n      programs,\n    }),\n    tokenAccount,\n  };\n};\n","import {\n  AuthorityType,\n  AuthorizationData,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { Metaplex } from '../../Metaplex';\nimport {\n  MetadataDelegateInput,\n  parseTokenMetadataDelegateInput,\n  TokenDelegateInput,\n} from './DelegateInput';\nimport { Signer, PublicKey, Program } from '@/types';\nimport { Option } from '@/utils';\nimport { UnreachableCaseError } from '@/errors';\n\n/**\n * Defines an authority that can handle a digital asset (NFT, SFT, etc.).\n *\n * An authority can be one of the following:\n * - Metadata: the update authority of the metadata account.\n * - Holder: the owner of the token account, i.e. the owner of the asset.\n * - Metadata Delegate: an approved delegate authority of the metadata account for a given action.\n * - Token Delegate: an approved delegate authority of the token account for a given action.\n */\nexport type TokenMetadataAuthority =\n  | TokenMetadataAuthorityMetadata\n  | TokenMetadataAuthorityHolder\n  | TokenMetadataAuthorityMetadataDelegate\n  | TokenMetadataAuthorityTokenDelegate;\n\n/** The update authority of the metadata account. */\nexport type TokenMetadataAuthorityMetadata = {\n  __kind: 'metadata';\n  updateAuthority: Signer;\n  token?: PublicKey;\n};\n\n/** An approved delegate authority of the metadata account for a given action. */\nexport type TokenMetadataAuthorityMetadataDelegate =\n  MetadataDelegateInput<Signer> & {\n    __kind: 'metadataDelegate';\n  };\n\n/** An approved delegate authority of the token account for a given action. */\nexport type TokenMetadataAuthorityTokenDelegate = TokenDelegateInput<Signer> & {\n  __kind: 'tokenDelegate';\n};\n\n/** The owner of the token account, i.e. the owner of the asset. */\nexport type TokenMetadataAuthorityHolder = {\n  __kind: 'holder';\n  owner: Signer;\n  token: PublicKey;\n};\n\n/**\n * Allows us to provide additional authorization details for an operation.\n *\n * This includes:\n * - The account defining the rules that should be used to authorize the operation.\n * - Optionally, the extra data that should be used by those rules.\n */\nexport type TokenMetadataAuthorizationDetails = {\n  rules: PublicKey;\n  data?: AuthorizationData;\n};\n\nexport type ParsedTokenMetadataAuthorization = {\n  accounts: {\n    /** The authority that will sign the transaction. */\n    authority: PublicKey;\n    /**\n     * If \"holder\" or \"token delegate\" authority,\n     * the address of the token account.\n     */\n    token?: PublicKey;\n    /**\n     * If \"delegate\" authority, the address of the update\n     * authority or the token owner depending on the type.\n     */\n    approver?: PublicKey;\n    /**\n     * If \"delegate\" authority, the address of the token record\n     * or the metadata delegate record PDA depending on the type.\n     */\n    delegateRecord?: PublicKey;\n    /** If any auth rules are provided, the address of the auth rule account. */\n    authorizationRules?: PublicKey;\n  };\n  signers: Signer[];\n  data: {\n    authorityType: AuthorityType;\n    authorizationData: Option<AuthorizationData>;\n  };\n};\n\nexport const parseTokenMetadataAuthorization = (\n  metaplex: Metaplex,\n  input: {\n    mint: PublicKey;\n    authority: TokenMetadataAuthority;\n    authorizationDetails?: TokenMetadataAuthorizationDetails;\n    programs?: Program[];\n  }\n): ParsedTokenMetadataAuthorization => {\n  const auth = {\n    accounts: { authorizationRules: input.authorizationDetails?.rules ?? null },\n    signers: [] as Signer[],\n    data: { authorizationData: input.authorizationDetails?.data ?? null },\n  } as ParsedTokenMetadataAuthorization;\n\n  if (input.authority.__kind === 'metadata') {\n    auth.accounts.authority = input.authority.updateAuthority.publicKey;\n    auth.accounts.token = input.authority.token;\n    auth.signers.push(input.authority.updateAuthority);\n    auth.data.authorityType = AuthorityType.Metadata;\n  } else if (input.authority.__kind === 'metadataDelegate') {\n    const { delegateRecord, approver } = parseTokenMetadataDelegateInput(\n      metaplex,\n      input.mint,\n      input.authority,\n      input.programs\n    );\n    auth.accounts.authority = input.authority.delegate.publicKey;\n    auth.accounts.delegateRecord = delegateRecord;\n    auth.accounts.approver = approver;\n    auth.signers.push(input.authority.delegate);\n    auth.data.authorityType = AuthorityType.MetadataDelegate;\n  } else if (input.authority.__kind === 'tokenDelegate') {\n    const { delegateRecord, approver, tokenAccount } =\n      parseTokenMetadataDelegateInput(\n        metaplex,\n        input.mint,\n        input.authority,\n        input.programs\n      );\n    auth.accounts.authority = input.authority.delegate.publicKey;\n    auth.accounts.token = tokenAccount;\n    auth.accounts.delegateRecord = delegateRecord;\n    auth.accounts.approver = approver;\n    auth.signers.push(input.authority.delegate);\n    auth.data.authorityType = AuthorityType.TokenDelegate;\n  } else if (input.authority.__kind === 'holder') {\n    auth.accounts.authority = input.authority.owner.publicKey;\n    auth.accounts.token = input.authority.token;\n    auth.signers.push(input.authority.owner);\n    auth.data.authorityType = AuthorityType.Holder;\n  } else {\n    throw new UnreachableCaseError((input.authority as any).__kind as never);\n  }\n\n  return auth;\n};\n\nexport const getSignerFromTokenMetadataAuthority = (\n  authority: TokenMetadataAuthority | Signer\n): Signer => {\n  if (!('__kind' in authority)) {\n    return authority;\n  }\n\n  switch (authority.__kind) {\n    case 'metadata':\n      return authority.updateAuthority;\n    case 'metadataDelegate':\n    case 'tokenDelegate':\n      return authority.delegate;\n    case 'holder':\n      return authority.owner;\n    default:\n      throw new UnreachableCaseError((authority as any).__kind as never);\n  }\n};\n","import {\n  CollectionDetails,\n  createUpdateInstruction,\n  UpdateArgs,\n  Uses,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport isEqual from 'lodash.isequal';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  parseTokenMetadataAuthorization,\n  TokenMetadataAuthority,\n  TokenMetadataAuthorizationDetails,\n} from '../Authorization';\nimport { isNonFungible, Sft } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  CreatorInput,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\nimport { NoInstructionsToSendError } from '@/errors';\n\nconst TOKEN_AUTH_RULES_ID = new PublicKey(\n  'auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg'\n);\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UpdateNftOperation' as const;\n\n/**\n * Updates an existing NFT or SFT.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .update({ nftOrSft, name: \"My new NFT name\" });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const updateNftOperation = useOperation<UpdateNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UpdateNftOperation = Operation<\n  typeof Key,\n  UpdateNftInput,\n  UpdateNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UpdateNftInput = {\n  /**\n   * The NFT or SFT to update.\n   * We only need a subset of the `Sft` (or `Nft`) model to figure out\n   * the current values for the data of the metadata account and only update\n   * the parts that are different.\n   */\n  nftOrSft: Pick<\n    Sft,\n    | 'address'\n    | 'collection'\n    | 'creators'\n    | 'name'\n    | 'symbol'\n    | 'uri'\n    | 'sellerFeeBasisPoints'\n    | 'uses'\n    | 'programmableConfig'\n    | 'tokenStandard'\n  >;\n\n  /**\n   * The current update authority of the asset as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   * @deprecated Use `authority` instead.\n   */\n  updateAuthority?: Signer;\n\n  /**\n   * An authority allowed to update the asset.\n   *\n   * If a `Signer` is provided directly,\n   * it will be used as the update authority.\n   *\n   * @see {@link TokenMetadataAuthority}\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer | TokenMetadataAuthority;\n\n  /**\n   * The authorization rules and data to use for the update.\n   *\n   * @see {@link TokenMetadataAuthorizationDetails}\n   * @defaultValue Defaults to not using auth rules.\n   */\n  authorizationDetails?: TokenMetadataAuthorizationDetails;\n\n  /**\n   * The address of the new update authority to set for the asset\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  newUpdateAuthority?: PublicKey;\n\n  /**\n   * The new on-chain name of the asset.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  name?: string;\n\n  /**\n   * The new on-chain symbol of the asset.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  symbol?: string;\n\n  /**\n   * The new on-chain uri of the asset.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  uri?: string;\n\n  /**\n   * The new royalties of the asset in percent basis point\n   * (i.e. 250 is 2.5%) that should be paid to the creators\n   * on each secondary sale.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  sellerFeeBasisPoints?: number;\n\n  /**\n   * The new creators for the asset.\n   * For each creator, if an `authority` Signer is provided,\n   * the creator will be marked as verified.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  creators?: CreatorInput[];\n\n  /**\n   * Whether or not the asset has already been sold to its first buyer.\n   * This can only be flipped from `false` to `true`.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  primarySaleHappened?: boolean;\n\n  /**\n   * Whether or not the asset is mutable.\n   * When set to `false` no one can update the Metadata account,\n   * not even the update authority.\n   * This can only be flipped from `true` to `false`.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  isMutable?: boolean;\n\n  /**\n   * When this field is not `null`, it indicates that the asset\n   * can be \"used\" by its owner or any approved \"use authorities\".\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  uses?: Option<Uses>;\n\n  /**\n   * The new Collection NFT that this asset belongs to.\n   * When `null`, this will remove the asset from its current collection.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  collection?: Option<PublicKey>;\n\n  /**\n   * The ruleset account that should be used to configure the\n   * programmable NFT.\n   *\n   * This is only relevant for programmable NFTs, i.e. if the\n   * `tokenStandard` is set to `TokenStandard.ProgrammableNonFungible`.\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  ruleSet?: Option<PublicKey>;\n\n  /**\n   * The collection authority that should sign the asset\n   * to prove that it is part of the newly provided collection.\n   * When `null`, the provided `collection` will not be verified.\n   *\n   * @defaultValue `null`\n   */\n  collectionAuthority?: Option<Signer>;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority\n   * using `metaplex.nfts().approveCollectionAuthority()`.\n   *\n   * @defaultValue `false`\n   */\n  collectionAuthorityIsDelegated?: boolean;\n\n  /**\n   * Whether or not the newly provided `collection` is a sized collection\n   * and not a legacy collection.\n   *\n   * @defaultValue `true`\n   */\n  collectionIsSized?: boolean;\n\n  /**\n   * The authority of the asset's current collection.\n   * This may be required if the current collection is being removed\n   * or updated and needs to be unverified before doing so.\n   *\n   * @defaultValue `payer`\n   */\n  oldCollectionAuthority?: Signer;\n\n  /**\n   * Whether or not the asset's current collection is a sized collection\n   * and not a legacy collection.\n   *\n   * @defaultValue `true`\n   */\n  oldCollectionIsSized?: boolean;\n\n  /**\n   * Transforms a regular NFT into a Collection NFT of the\n   * provided size.\n   *\n   * The provided size should include all **verified** NFTs\n   * and/or SFTs within the Collection. Unverified NFTs\n   * and/or SFTs should not be included in the size.\n   *\n   * **Warning, once set, this size can no longer be updated manually.**\n   *\n   * @defaultValue Defaults to not being updated.\n   */\n  collectionDetails?: CollectionDetails;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UpdateNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const updateNftOperationHandler: OperationHandler<UpdateNftOperation> = {\n  handle: async (\n    operation: UpdateNftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ): Promise<UpdateNftOutput> => {\n    const builder = updateNftBuilder(metaplex, operation.input, scope);\n\n    if (builder.isEmpty()) {\n      throw new NoInstructionsToSendError(Key);\n    }\n\n    return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UpdateNftBuilderParams = Omit<UpdateNftInput, 'confirmOptions'> & {\n  /** A key to distinguish the instruction that updates the metadata account. */\n  updateMetadataInstructionKey?: string;\n};\n\n/**\n * Updates an existing NFT or SFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .update({ nftOrSft, name: \"My new NFT name\" });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const updateNftBuilder = (\n  metaplex: Metaplex,\n  params: UpdateNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    nftOrSft,\n    updateAuthority = metaplex.identity(),\n    authority = updateAuthority,\n    authorizationDetails,\n  } = params;\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const systemProgram = metaplex.programs().getSystem(programs);\n\n  const updateInstructionDataWithoutChanges = toInstructionData(nftOrSft);\n  const updateInstructionData = toInstructionData(nftOrSft, params);\n  const shouldSendUpdateInstruction = !isEqual(\n    updateInstructionData,\n    updateInstructionDataWithoutChanges\n  );\n\n  const isRemovingVerifiedCollection =\n    !!nftOrSft.collection &&\n    !!nftOrSft.collection.verified &&\n    params.collection === null;\n  const isOverridingVerifiedCollection =\n    !!nftOrSft.collection &&\n    !!nftOrSft.collection.verified &&\n    !!params.collection &&\n    !params.collection.equals(nftOrSft.collection.address);\n  const shouldUnverifyCurrentCollection =\n    isRemovingVerifiedCollection || isOverridingVerifiedCollection;\n\n  // Auth.\n  const auth = parseTokenMetadataAuthorization(metaplex, {\n    mint: nftOrSft.address,\n    authority:\n      '__kind' in authority\n        ? authority\n        : { __kind: 'metadata', updateAuthority: authority },\n    authorizationDetails,\n    programs,\n  });\n\n  const creatorsInput: CreatorInput[] = params.creators ?? nftOrSft.creators;\n  const verifyAdditionalCreatorInstructions = creatorsInput\n    .filter((creator) => {\n      const currentCreator = nftOrSft.creators.find(({ address }) =>\n        address.equals(creator.address)\n      );\n      const currentlyVerified = currentCreator?.verified ?? false;\n      return !!creator.authority && !currentlyVerified;\n    })\n    .map((creator) => {\n      return metaplex.nfts().builders().verifyCreator(\n        {\n          mintAddress: nftOrSft.address,\n          creator: creator.authority,\n        },\n        { payer, programs }\n      );\n    });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Unverify current collection before overriding it.\n      // Otherwise, the previous collection size will not be properly decremented.\n      .when(shouldUnverifyCurrentCollection, (builder) =>\n        builder.add(\n          metaplex\n            .nfts()\n            .builders()\n            .unverifyCollection(\n              {\n                mintAddress: nftOrSft.address,\n                collectionMintAddress: nftOrSft.collection\n                  ?.address as PublicKey,\n                collectionAuthority: params.oldCollectionAuthority ?? payer,\n                isSizedCollection: params.oldCollectionIsSized ?? true,\n              },\n              { programs, payer }\n            )\n        )\n      )\n\n      // Update the metadata account.\n      .when(shouldSendUpdateInstruction, (builder) =>\n        builder.add({\n          instruction: createUpdateInstruction(\n            {\n              authority: auth.accounts.authority,\n              delegateRecord: auth.accounts.delegateRecord,\n              token: auth.accounts.token,\n              mint: nftOrSft.address,\n              metadata: metaplex.nfts().pdas().metadata({\n                mint: nftOrSft.address,\n                programs,\n              }),\n              edition: isNonFungible(nftOrSft)\n                ? metaplex.nfts().pdas().masterEdition({\n                    mint: nftOrSft.address,\n                    programs,\n                  })\n                : undefined,\n              // tokenRecord, // TODO\n              payer: payer.publicKey,\n              systemProgram: systemProgram.address,\n              sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n              authorizationRules: auth.accounts.authorizationRules,\n              authorizationRulesProgram: TOKEN_AUTH_RULES_ID,\n            },\n            {\n              updateArgs: { ...updateInstructionData, ...auth.data } as any,\n            },\n            tokenMetadataProgram.address\n          ),\n          signers: [payer, ...auth.signers],\n          key: params.updateMetadataInstructionKey ?? 'updateMetadata',\n        })\n      )\n\n      // Verify additional creators.\n      .add(...verifyAdditionalCreatorInstructions)\n\n      // Verify collection.\n      .when(!!params.collection && !!params.collectionAuthority, (builder) =>\n        builder.add(\n          metaplex\n            .nfts()\n            .builders()\n            .verifyCollection(\n              {\n                mintAddress: nftOrSft.address,\n                collectionMintAddress: params.collection as PublicKey,\n                collectionAuthority: params.collectionAuthority as Signer,\n                isDelegated: params.collectionAuthorityIsDelegated ?? false,\n                isSizedCollection: params.collectionIsSized ?? true,\n              },\n              { programs, payer }\n            )\n        )\n      )\n  );\n};\n\nconst toInstructionData = (\n  nftOrSft: Pick<\n    Sft,\n    | 'address'\n    | 'collection'\n    | 'creators'\n    | 'name'\n    | 'symbol'\n    | 'uri'\n    | 'sellerFeeBasisPoints'\n    | 'uses'\n    | 'programmableConfig'\n  >,\n  input: Partial<UpdateNftInput> = {}\n): Omit<UpdateArgs, 'authorityType' | 'authorizationData'> => {\n  const creators =\n    input.creators === undefined\n      ? nftOrSft.creators\n      : input.creators.map((creator) => {\n          const currentCreator = nftOrSft.creators.find(({ address }) =>\n            address.equals(creator.address)\n          );\n          return {\n            ...creator,\n            verified: currentCreator?.verified ?? false,\n          };\n        });\n\n  return <Omit<UpdateArgs, 'authorityType' | 'authorizationData'>>{\n    __kind: 'V1',\n    newUpdateAuthority: input.newUpdateAuthority ?? null,\n    data: {\n      name: input.name ?? nftOrSft.name,\n      symbol: input.symbol ?? nftOrSft.symbol,\n      uri: input.uri ?? nftOrSft.uri,\n      sellerFeeBasisPoints:\n        input.sellerFeeBasisPoints ?? nftOrSft.sellerFeeBasisPoints,\n      creators: creators.length > 0 ? creators : null,\n    },\n    primarySaleHappened: input.primarySaleHappened ?? null,\n    isMutable: input.isMutable ?? null,\n    collection: input.collection\n      ? { __kind: 'Set', fields: [{ key: input.collection, verified: false }] }\n      : { __kind: input.collection === undefined ? 'None' : 'Clear' },\n    collectionDetails: input.collectionDetails\n      ? { __kind: 'Set', fields: [input.collectionDetails] }\n      : { __kind: 'None' },\n    uses: input.uses\n      ? { __kind: 'Set', fields: [input.uses] }\n      : { __kind: input.uses === undefined ? 'None' : 'Clear' },\n    ruleSet: input.ruleSet\n      ? { __kind: 'Set', fields: [input.ruleSet] }\n      : { __kind: input.ruleSet === undefined ? 'None' : 'Clear' },\n  };\n};\n","import { createBurnInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  TokenMetadataAuthorityHolder,\n  TokenMetadataAuthorityTokenDelegate,\n  getSignerFromTokenMetadataAuthority,\n  parseTokenMetadataAuthorization,\n} from '../Authorization';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  token,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'DeleteNftOperation' as const;\n\n/**\n * Deletes an existing NFT.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .delete({ mintAddress };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const deleteNftOperation = useOperation<DeleteNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type DeleteNftOperation = Operation<\n  typeof Key,\n  DeleteNftInput,\n  DeleteNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type DeleteNftInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /**\n   * An authority allowed to burn the asset.\n   *\n   * Note that Metadata authorities are\n   * not supported for this instruction.\n   *\n   * If a `Signer` is provided directly,\n   * it will be used as an Holder authority.\n   *\n   * @see {@link TokenMetadataAuthority}\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?:\n    | Signer\n    | TokenMetadataAuthorityTokenDelegate\n    | TokenMetadataAuthorityHolder;\n\n  /**\n   * Alias of `authority` for backwards compatibility.\n   *\n   * @deprecated Use `authority` instead.\n   * @see {@link DeleteNftInput.authority}\n   */\n  owner?: Signer;\n\n  /**\n   * The mint of the parent edition when the asset is a printed edition.\n   *\n   * @defaultValue Defaults to not providing a parent edition to the program.\n   */\n  parentEditionMint?: PublicKey;\n\n  /**\n   * The token account of the parent edition when the asset is a printed edition.\n   *\n   * @defaultValue Defaults to not providing a parent edition to the program.\n   */\n  parentEditionToken?: PublicKey;\n\n  /**\n   * The edition marker of the asset if it is a printed edition.\n   *\n   * @defaultValue Defaults to not providing the edition marker to the program.\n   */\n  editionMarker?: PublicKey;\n\n  /**\n   * The explicit token account linking the provided mint and owner\n   * accounts, if that account is not their associated token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `owner` parameters.\n   */\n  ownerTokenAccount?: PublicKey;\n\n  /**\n   * The address of the Sized Collection NFT associated with the\n   * NFT to delete, if any. This is required as the collection NFT\n   * will need to decrement its size.\n   *\n   * @defaultValue Defaults to assuming the NFT is not associated with a\n   * Size Collection NFT.\n   */\n  collection?: PublicKey;\n\n  /**\n   * The amount of tokens to burn.\n   *\n   * @defaultValue `token(1)`\n   */\n  amount?: SplTokenAmount;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type DeleteNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const deleteNftOperationHandler: OperationHandler<DeleteNftOperation> = {\n  handle: async (\n    operation: DeleteNftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ): Promise<DeleteNftOutput> => {\n    return deleteNftBuilder(metaplex, operation.input, scope).sendAndConfirm(\n      metaplex,\n      scope.confirmOptions\n    );\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type DeleteNftBuilderParams = Omit<DeleteNftInput, 'confirmOptions'> & {\n  /** A key to distinguish the instruction that burns the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Deletes an existing NFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .delete({ mintAddress });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const deleteNftBuilder = (\n  metaplex: Metaplex,\n  params: DeleteNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    ownerTokenAccount,\n    collection,\n    parentEditionMint,\n    parentEditionToken,\n    editionMarker,\n    amount = token(1),\n  } = params;\n\n  const authority =\n    params.authority ?? params.owner ?? (metaplex.identity() as Signer);\n\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  const owner = getSignerFromTokenMetadataAuthority(authority).publicKey;\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const edition = metaplex.nfts().pdas().masterEdition({\n    mint: mintAddress,\n    programs,\n  });\n  const tokenAddress =\n    ownerTokenAccount ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner,\n      programs,\n    });\n\n  // Auth.\n  const auth = parseTokenMetadataAuthorization(metaplex, {\n    mint: mintAddress,\n    authority:\n      '__kind' in authority\n        ? authority\n        : { __kind: 'holder', owner: authority, token: tokenAddress },\n    programs,\n  });\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createBurnInstruction(\n        {\n          authority: auth.accounts.authority,\n          collectionMetadata: collection\n            ? metaplex.nfts().pdas().metadata({ mint: collection, programs })\n            : undefined,\n          metadata,\n          edition,\n          mint: mintAddress,\n          token: auth.accounts.token!,\n          masterEdition: parentEditionMint\n            ? metaplex.nfts().pdas().metadata({\n                mint: parentEditionMint,\n                programs,\n              })\n            : undefined,\n          masterEditionMint: parentEditionMint,\n          masterEditionToken: parentEditionToken,\n          editionMarker,\n          tokenRecord: auth.accounts.delegateRecord,\n          systemProgram: systemProgram.address,\n          sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n          splTokenProgram: tokenProgram.address,\n        },\n        { burnArgs: { __kind: 'V1', amount: amount.basisPoints } },\n        tokenMetadataProgram.address\n      ),\n      signers: auth.signers,\n      key: params.instructionKey ?? 'deleteNft',\n    });\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { MetadataDelegateType, TokenDelegateType } from './DelegateType';\nimport { MetaplexError } from '@/errors';\n\n/** @group Errors */\nexport class NftError extends MetaplexError {\n  readonly name: string = 'NftError';\n  constructor(message: string, cause?: Error) {\n    super(message, 'plugin', 'NFT', cause);\n  }\n}\n\n/** @group Errors */\nexport class ParentCollectionMissingError extends NftError {\n  readonly name: string = 'ParentCollectionMissingError';\n  constructor(mint: PublicKey, operation: string) {\n    const message =\n      `You are trying to send the operation [${operation}] which requires the NFT to have ` +\n      `a parent collection but that is not the case for the NFT at address [${mint}]. ` +\n      'Ensure the NFT you are interacting with has a parent collection.';\n    super(message);\n  }\n}\n\n/** @group Errors */\nexport class DelegateRoleRequiredDataError extends NftError {\n  readonly name: string = 'DelegateRoleRequiredDataError';\n  constructor(type: MetadataDelegateType | TokenDelegateType) {\n    const message =\n      `You are trying to approve a delegate of type \"${type}\" ` +\n      `but did not provide any data for that role. Please provide the \"data\" ` +\n      'attribute as the SDK cannot provide a default value for that role.';\n    super(message);\n  }\n}\n","import {\n  DelegateArgs,\n  TokenDelegateRole,\n  MetadataDelegateRole,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { DelegateRoleRequiredDataError } from './errors';\nimport { UnreachableCaseError } from '@/errors';\n\nexport type TokenDelegateType =\n  | 'StandardV1'\n  | 'TransferV1'\n  | 'LockedTransferV1'\n  | 'SaleV1'\n  | 'UtilityV1'\n  | 'StakingV1';\nexport type MetadataDelegateType =\n  // | 'AuthorityItemV1'\n  | 'CollectionV1'\n  // | 'UseV1'\n  | 'DataV1'\n  | 'ProgrammableConfigV1';\n\nconst tokenDelegateRoleMap: Record<TokenDelegateType, TokenDelegateRole> = {\n  StandardV1: TokenDelegateRole.Standard,\n  TransferV1: TokenDelegateRole.Transfer,\n  LockedTransferV1: TokenDelegateRole.LockedTransfer,\n  SaleV1: TokenDelegateRole.Sale,\n  UtilityV1: TokenDelegateRole.Utility,\n  StakingV1: TokenDelegateRole.Staking,\n};\n\nconst metadataDelegateRoleMap: Record<\n  MetadataDelegateType,\n  MetadataDelegateRole\n> = {\n  // AuthorityItemV1: MetadataDelegateRole.AuthorityItem,\n  CollectionV1: MetadataDelegateRole.Collection,\n  // UseV1: MetadataDelegateRole.Use,\n  DataV1: MetadataDelegateRole.Data,\n  ProgrammableConfigV1: MetadataDelegateRole.ProgrammableConfig,\n};\n\nconst metadataDelegateSeedMap: Record<MetadataDelegateRole, string> = {\n  [MetadataDelegateRole.AuthorityItem]: 'authority_item_delegate',\n  [MetadataDelegateRole.Collection]: 'collection_delegate',\n  [MetadataDelegateRole.Use]: 'use_delegate',\n  [MetadataDelegateRole.Data]: 'data_delegate',\n  [MetadataDelegateRole.ProgrammableConfig]: 'programmable_config_delegate',\n  [MetadataDelegateRole.DataItem]: 'data_item_delegate',\n  [MetadataDelegateRole.CollectionItem]: 'collection_item_delegate',\n  [MetadataDelegateRole.ProgrammableConfigItem]: 'prog_config_item_delegate',\n};\n\nconst delegateCustomDataMap: Record<\n  TokenDelegateType | MetadataDelegateType,\n  boolean\n> = {\n  // Metadata.\n  // AuthorityItemV1: false,\n  CollectionV1: false,\n  // UseV1: false,\n  DataV1: false,\n  ProgrammableConfigV1: false,\n  // Token\n  StandardV1: true,\n  TransferV1: true,\n  SaleV1: true,\n  UtilityV1: true,\n  StakingV1: true,\n  LockedTransferV1: true,\n};\n\nexport const getTokenDelegateRole = (\n  type: TokenDelegateType\n): TokenDelegateRole => {\n  const role = tokenDelegateRoleMap[type];\n  if (!role) throw new UnreachableCaseError(type as never);\n  return role;\n};\n\nexport const getMetadataDelegateRole = (\n  type: MetadataDelegateType\n): MetadataDelegateRole => {\n  const role = metadataDelegateRoleMap[type];\n  if (!role) throw new UnreachableCaseError(type as never);\n  return role;\n};\n\nexport const getMetadataDelegateRoleSeed = (\n  type: MetadataDelegateType\n): string => {\n  return metadataDelegateSeedMap[getMetadataDelegateRole(type)];\n};\n\nexport const getDefaultDelegateArgs = (\n  type: TokenDelegateType | MetadataDelegateType\n): Omit<DelegateArgs, 'authorizationData'> => {\n  const hasCustomData = delegateCustomDataMap[type];\n  if (hasCustomData === undefined)\n    throw new UnreachableCaseError(type as never);\n  if (hasCustomData) throw new DelegateRoleRequiredDataError(type);\n  return { __kind: type } as DelegateArgs;\n};\n","import {\n  createDelegateInstruction,\n  DelegateArgs,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  parseTokenMetadataAuthorization,\n  TokenMetadataAuthority,\n  TokenMetadataAuthorityHolder,\n  TokenMetadataAuthorityMetadata,\n  TokenMetadataAuthorizationDetails,\n} from '../Authorization';\nimport {\n  DelegateInputWithData,\n  parseTokenMetadataDelegateInput,\n} from '../DelegateInput';\nimport { getDefaultDelegateArgs } from '../DelegateType';\nimport { isNonFungible, Sft } from '../models';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  PublicKey,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\nconst TOKEN_AUTH_RULES_ID = new PublicKey(\n  'auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg'\n);\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'ApproveNftDelegateOperation' as const;\n\n/**\n * Approve a new delegate authority for an NFT or SFT.\n *\n * ```ts\n * await metaplex.nfts().delegate({\n *   nftOrSft,\n *   delegate,\n *   delegateArgs\n * });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const approveNftDelegateOperation =\n  useOperation<ApproveNftDelegateOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type ApproveNftDelegateOperation = Operation<\n  typeof Key,\n  ApproveNftDelegateInput,\n  ApproveNftDelegateOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type ApproveNftDelegateInput = {\n  /**\n   * The NFT or SFT for which we want to approve a delegate.\n   * We only need its address and token standard.\n   */\n  nftOrSft: Pick<Sft, 'address' | 'tokenStandard'>;\n\n  /**\n   * An authority allowed to approve a new delegate authority.\n   *\n   * Note that Delegate authorities are not supported for this\n   * instruction as delegates cannot approve other delegates.\n   *\n   * If a `Signer` is provided directly, it will be either\n   * used as the update authority or as the token holder\n   * based on the delegate type, i.g. `delegate.type`.\n   *\n   * @see {@link TokenMetadataAuthority}\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?:\n    | Signer\n    | TokenMetadataAuthorityMetadata\n    | TokenMetadataAuthorityHolder;\n\n  /**\n   * The authorization rules and data to use\n   * when approving the delegate authority.\n   *\n   * @see {@link TokenMetadataAuthorizationDetails}\n   * @defaultValue Defaults to not using auth rules.\n   */\n  authorizationDetails?: TokenMetadataAuthorizationDetails;\n\n  /**\n   * The role, address, approver and data of the delegate to approve.\n   */\n  delegate: DelegateInputWithData;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type ApproveNftDelegateOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const approveNftDelegateOperationHandler: OperationHandler<ApproveNftDelegateOperation> =\n  {\n    handle: async (\n      operation: ApproveNftDelegateOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<ApproveNftDelegateOutput> => {\n      return approveNftDelegateBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type ApproveNftDelegateBuilderParams = Omit<\n  ApproveNftDelegateInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that uses the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Approve a new delegate authority for an NFT or SFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .delegate({\n *     nftOrSft,\n *     delegate,\n *     delegateArgs\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const approveNftDelegateBuilder = (\n  metaplex: Metaplex,\n  params: ApproveNftDelegateBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    nftOrSft,\n    authority = metaplex.identity(),\n    authorizationDetails,\n  } = params;\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const systemProgram = metaplex.programs().getSystem(programs);\n\n  // PDAs.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: nftOrSft.address,\n    programs,\n  });\n  const masterEdition = metaplex.nfts().pdas().masterEdition({\n    mint: nftOrSft.address,\n    programs,\n  });\n\n  // New Delegate.\n  const { delegateRecord, delegate, isTokenDelegate } =\n    parseTokenMetadataDelegateInput(\n      metaplex,\n      nftOrSft.address,\n      params.delegate,\n      programs\n    );\n\n  // Auth.\n  let tokenMetadataAuthority: TokenMetadataAuthority;\n  if ('__kind' in authority) {\n    tokenMetadataAuthority = authority;\n  } else if ('owner' in params.delegate) {\n    tokenMetadataAuthority = {\n      __kind: 'holder',\n      owner: authority,\n      token: metaplex.tokens().pdas().associatedTokenAccount({\n        mint: nftOrSft.address,\n        owner: authority.publicKey,\n        programs,\n      }),\n    };\n  } else {\n    tokenMetadataAuthority = { __kind: 'metadata', updateAuthority: authority };\n  }\n\n  const auth = parseTokenMetadataAuthorization(metaplex, {\n    mint: nftOrSft.address,\n    authority: tokenMetadataAuthority,\n    authorizationDetails,\n    programs,\n  });\n\n  const delegateArgsWithoutAuthData: Omit<DelegateArgs, 'authorizationData'> =\n    params.delegate.data === undefined\n      ? getDefaultDelegateArgs(params.delegate.type)\n      : {\n          __kind: params.delegate.type,\n          ...params.delegate.data,\n        };\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update the metadata account.\n      .add({\n        instruction: createDelegateInstruction(\n          {\n            delegateRecord,\n            delegate,\n            metadata,\n            masterEdition: isNonFungible(nftOrSft) ? masterEdition : undefined,\n            tokenRecord: isTokenDelegate ? delegateRecord : undefined,\n            mint: nftOrSft.address,\n            token: auth.accounts.token,\n            authority: auth.accounts.authority,\n            payer: payer.publicKey,\n            systemProgram: systemProgram.address,\n            sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n            splTokenProgram: tokenProgram.address,\n            authorizationRules: auth.accounts.authorizationRules,\n            authorizationRulesProgram: TOKEN_AUTH_RULES_ID,\n          },\n          {\n            delegateArgs: {\n              ...delegateArgsWithoutAuthData,\n              ...auth.data,\n            } as DelegateArgs,\n          },\n          tokenMetadataProgram.address\n        ),\n        signers: [payer, ...auth.signers],\n        key: params.instructionKey ?? 'approveNftDelegate',\n      })\n  );\n};\n","import {\n  createRevokeInstruction,\n  RevokeArgs,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  parseTokenMetadataAuthorization,\n  TokenMetadataAuthority,\n  TokenMetadataAuthorityHolder,\n  TokenMetadataAuthorityMetadata,\n  TokenMetadataAuthorizationDetails,\n} from '../Authorization';\nimport {\n  DelegateInput,\n  parseTokenMetadataDelegateInput,\n} from '../DelegateInput';\nimport { isNonFungible, Sft } from '../models';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  PublicKey,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\nconst TOKEN_AUTH_RULES_ID = new PublicKey(\n  'auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg'\n);\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'RevokeNftDelegateOperation' as const;\n\n/**\n * Revoke an existing delegate authority for an NFT or SFT.\n *\n * ```ts\n * await metaplex.nfts().revoke({ sftOrNft, delegate });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const revokeNftDelegateOperation =\n  useOperation<RevokeNftDelegateOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type RevokeNftDelegateOperation = Operation<\n  typeof Key,\n  RevokeNftDelegateInput,\n  RevokeNftDelegateOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type RevokeNftDelegateInput = {\n  /**\n   * The NFT or SFT for which we want to revoke a delegate.\n   * We only need its address and token standard.\n   */\n  nftOrSft: Pick<Sft, 'address' | 'tokenStandard'>;\n\n  /**\n   * An authority allowed to revoke a new delegate authority.\n   *\n   * Note that Delegate authorities are not supported for this\n   * instruction as delegates cannot revoke other delegates.\n   *\n   * If a `Signer` is provided directly, it will be either\n   * used as the update authority or as the token holder\n   * based on the delegate type, i.g. `delegate.type`.\n   *\n   * If a `{ __kind: 'self'; delegate: Signer }` is\n   * provided, it will assume the delegate\n   * authority is trying to revoke itself.\n   *\n   * @see {@link TokenMetadataAuthority}\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?:\n    | Signer\n    | { __kind: 'self'; delegate: Signer }\n    | TokenMetadataAuthorityMetadata\n    | TokenMetadataAuthorityHolder;\n\n  /**\n   * The authorization rules and data to use\n   * when revoking the delegate authority.\n   *\n   * @see {@link TokenMetadataAuthorizationDetails}\n   * @defaultValue Defaults to not using auth rules.\n   */\n  authorizationDetails?: TokenMetadataAuthorizationDetails;\n\n  /**\n   * The role, address and approver of the delegate to revoke.\n   */\n  delegate: DelegateInput;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type RevokeNftDelegateOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const revokeNftDelegateOperationHandler: OperationHandler<RevokeNftDelegateOperation> =\n  {\n    handle: async (\n      operation: RevokeNftDelegateOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<RevokeNftDelegateOutput> => {\n      return revokeNftDelegateBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type RevokeNftDelegateBuilderParams = Omit<\n  RevokeNftDelegateInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that uses the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Revoke an existing delegate authority for an NFT or SFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .revoke({ sftOrNft, delegate });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const revokeNftDelegateBuilder = (\n  metaplex: Metaplex,\n  params: RevokeNftDelegateBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    nftOrSft,\n    authority = metaplex.identity(),\n    authorizationDetails,\n  } = params;\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const systemProgram = metaplex.programs().getSystem(programs);\n\n  // PDAs.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: nftOrSft.address,\n    programs,\n  });\n  const masterEdition = metaplex.nfts().pdas().masterEdition({\n    mint: nftOrSft.address,\n    programs,\n  });\n\n  // Delegate to revoke.\n  const { delegateRecord, delegate, tokenAccount, isTokenDelegate } =\n    parseTokenMetadataDelegateInput(\n      metaplex,\n      nftOrSft.address,\n      params.delegate,\n      programs\n    );\n\n  // Auth.\n  let tokenMetadataAuthority: TokenMetadataAuthority;\n  if (!('__kind' in authority)) {\n    tokenMetadataAuthority =\n      'owner' in params.delegate\n        ? {\n            __kind: 'holder',\n            owner: authority,\n            token: metaplex.tokens().pdas().associatedTokenAccount({\n              mint: nftOrSft.address,\n              owner: authority.publicKey,\n              programs,\n            }),\n          }\n        : { __kind: 'metadata', updateAuthority: authority };\n  } else if (authority.__kind === 'self') {\n    tokenMetadataAuthority = {\n      ...params.delegate,\n      __kind: 'owner' in params.delegate ? 'tokenDelegate' : 'metadataDelegate',\n      delegate: authority.delegate,\n    } as TokenMetadataAuthority;\n  } else {\n    tokenMetadataAuthority = authority;\n  }\n  const auth = parseTokenMetadataAuthorization(metaplex, {\n    mint: nftOrSft.address,\n    authority: tokenMetadataAuthority,\n    authorizationDetails,\n    programs,\n  });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update the metadata account.\n      .add({\n        instruction: createRevokeInstruction(\n          {\n            delegateRecord,\n            delegate,\n            metadata,\n            masterEdition: isNonFungible(nftOrSft) ? masterEdition : undefined,\n            tokenRecord: isTokenDelegate ? delegateRecord : undefined,\n            mint: nftOrSft.address,\n            token: tokenAccount,\n            authority: auth.accounts.authority,\n            payer: payer.publicKey,\n            systemProgram: systemProgram.address,\n            sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n            splTokenProgram: tokenProgram.address,\n            authorizationRules: auth.accounts.authorizationRules,\n            authorizationRulesProgram: TOKEN_AUTH_RULES_ID,\n          },\n          {\n            revokeArgs: RevokeArgs[params.delegate.type],\n          },\n          tokenMetadataProgram.address\n        ),\n        signers: [payer, ...auth.signers],\n        key: params.instructionKey ?? 'revokeNftDelegate',\n      })\n  );\n};\n","import { createUtilizeInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { ExpectedSignerError } from '@/errors';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  isSigner,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UseNftOperation' as const;\n\n/**\n * Utilizes a usable NFT.\n *\n * ```ts\n * await metaplex.nfts().use({ mintAddress });\n * await metaplex.nfts().use({ mintAddress, numberOfUses: 3 });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const useNftOperation = useOperation<UseNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UseNftOperation = Operation<typeof Key, UseNftInput, UseNftOutput>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UseNftInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /**\n   * The number of uses to utilize.\n   *\n   * @defaultValue `1`\n   */\n  numberOfUses?: number; // Defaults to 1.\n\n  /**\n   * The owner of the NFT or SFT.\n   *\n   * This must be a Signer unless a `useAuthority` is provided.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  owner?: PublicKey | Signer;\n\n  /**\n   * The address of the token account linking the mint account\n   * with the owner account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `owner` parameters.\n   */\n  ownerTokenAccount?: PublicKey;\n\n  /**\n   * The delegated use authority that should authorize this operation.\n   *\n   * @defaultValue Defaults to not using a delegated use authority\n   * and using the `owner` parameter as a Signer instead.\n   */\n  useAuthority?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UseNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const useNftOperationHandler: OperationHandler<UseNftOperation> = {\n  handle: async (\n    operation: UseNftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ): Promise<UseNftOutput> => {\n    return useNftBuilder(metaplex, operation.input, scope).sendAndConfirm(\n      metaplex,\n      scope.confirmOptions\n    );\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UseNftBuilderParams = Omit<UseNftInput, 'confirmOptions'> & {\n  /** A key to distinguish the instruction that uses the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Utilizes a usable NFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .use({ mintAddress });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const useNftBuilder = (\n  metaplex: Metaplex,\n  params: UseNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    numberOfUses = 1,\n    owner = metaplex.identity(),\n    useAuthority,\n  } = params;\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  if (!isSigner(owner) && !useAuthority) {\n    throw new ExpectedSignerError(\n      'owner',\n      'PublicKey',\n      'In order to use an NFT you must either provide the owner as a Signer ' +\n        'or a delegated use authority as a Signer.'\n    );\n  }\n\n  // PDAs.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const tokenAccount =\n    params.ownerTokenAccount ??\n    metaplex\n      .tokens()\n      .pdas()\n      .associatedTokenAccount({\n        mint: mintAddress,\n        owner: toPublicKey(owner),\n        programs,\n      });\n  const useAuthorityRecord = useAuthority\n    ? metaplex.nfts().pdas().useAuthorityRecord({\n        mint: mintAddress,\n        useAuthority: useAuthority.publicKey,\n        programs,\n      })\n    : undefined;\n  const programAsBurner = metaplex.nfts().pdas().burner({ programs });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update the metadata account.\n      .add({\n        instruction: createUtilizeInstruction(\n          {\n            metadata,\n            tokenAccount,\n            useAuthority: useAuthority\n              ? useAuthority.publicKey\n              : toPublicKey(owner),\n            mint: mintAddress,\n            owner: toPublicKey(owner),\n            useAuthorityRecord,\n            burner: useAuthorityRecord ? programAsBurner : undefined,\n          },\n          { utilizeArgs: { numberOfUses } },\n          tokenMetadataProgram.address\n        ),\n        signers: [owner, useAuthority].filter(isSigner),\n        key: params.instructionKey ?? 'utilizeNft',\n      })\n  );\n};\n","import { createApproveUseAuthorityInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'ApproveNftUseAuthorityOperation' as const;\n\n/**\n * Approves a new use authority.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .approveUseAuthority({ mintAddress, user };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const approveNftUseAuthorityOperation =\n  useOperation<ApproveNftUseAuthorityOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type ApproveNftUseAuthorityOperation = Operation<\n  typeof Key,\n  ApproveNftUseAuthorityInput,\n  ApproveNftUseAuthorityOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type ApproveNftUseAuthorityInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The address of the use authority to approve. */\n  user: PublicKey;\n\n  /**\n   * The owner of the NFT or SFT as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  owner?: Signer;\n\n  /**\n   * The address of the token account linking the mint account\n   * with the owner account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `owner` parameters.\n   */\n  ownerTokenAddress?: PublicKey;\n\n  /**\n   * The number of usages this new use authority\n   * is allowed to perform.\n   *\n   * @defaultValue `1`\n   */\n  numberOfUses?: number;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type ApproveNftUseAuthorityOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const approveNftUseAuthorityOperationHandler: OperationHandler<ApproveNftUseAuthorityOperation> =\n  {\n    handle: async (\n      operation: ApproveNftUseAuthorityOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<ApproveNftUseAuthorityOutput> => {\n      return approveNftUseAuthorityBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type ApproveNftUseAuthorityBuilderParams = Omit<\n  ApproveNftUseAuthorityInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that approves the use authority. */\n  instructionKey?: string;\n};\n\n/**\n * Approves a new use authority.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .approveUseAuthority({ mintAddress, user });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const approveNftUseAuthorityBuilder = (\n  metaplex: Metaplex,\n  params: ApproveNftUseAuthorityBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { mintAddress, user, owner = metaplex.identity() } = params;\n\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const useAuthorityRecord = metaplex.nfts().pdas().useAuthorityRecord({\n    mint: mintAddress,\n    useAuthority: user,\n    programs,\n  });\n  const programAsBurner = metaplex.nfts().pdas().burner({\n    programs,\n  });\n  const ownerTokenAddress =\n    params.ownerTokenAddress ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: owner.publicKey,\n      programs,\n    });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Approve the use authority.\n      .add({\n        instruction: createApproveUseAuthorityInstruction(\n          {\n            useAuthorityRecord,\n            owner: owner.publicKey,\n            payer: payer.publicKey,\n            user,\n            ownerTokenAccount: ownerTokenAddress,\n            metadata,\n            mint: mintAddress,\n            burner: programAsBurner,\n            tokenProgram: tokenProgram.address,\n            systemProgram: systemProgram.address,\n          },\n          {\n            approveUseAuthorityArgs: {\n              numberOfUses: params.numberOfUses ?? 1,\n            },\n          },\n          tokenMetadataProgram.address\n        ),\n        signers: [owner, payer],\n        key: params.instructionKey ?? 'approveUseAuthority',\n      })\n  );\n};\n","import { createRevokeUseAuthorityInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'RevokeNftUseAuthorityOperation' as const;\n\n/**\n * Revokes an existing use authority.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .revokeUseAuthority({ mintAddress, user };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const revokeNftUseAuthorityOperation =\n  useOperation<RevokeNftUseAuthorityOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type RevokeNftUseAuthorityOperation = Operation<\n  typeof Key,\n  RevokeNftUseAuthorityInput,\n  RevokeNftUseAuthorityOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type RevokeNftUseAuthorityInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The address of the use authority to revoke. */\n  user: PublicKey;\n\n  /**\n   * The owner of the NFT or SFT as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  owner?: Signer;\n\n  /**\n   * The address of the token account linking the mint account\n   * with the owner account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `owner` parameters.\n   */\n  ownerTokenAddress?: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type RevokeNftUseAuthorityOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const revokeNftUseAuthorityOperationHandler: OperationHandler<RevokeNftUseAuthorityOperation> =\n  {\n    handle: async (\n      operation: RevokeNftUseAuthorityOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<RevokeNftUseAuthorityOutput> => {\n      return revokeNftUseAuthorityBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type RevokeNftUseAuthorityBuilderParams = Omit<\n  RevokeNftUseAuthorityInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that revokes the use authority. */\n  instructionKey?: string;\n};\n\n/**\n * Revokes an existing use authority.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .revokeUseAuthority({ mintAddress, user });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const revokeNftUseAuthorityBuilder = (\n  metaplex: Metaplex,\n  params: RevokeNftUseAuthorityBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { mintAddress, user, owner = metaplex.identity() } = params;\n\n  // Programs.\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  // PDAs.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const useAuthorityRecord = metaplex.nfts().pdas().useAuthorityRecord({\n    mint: mintAddress,\n    useAuthority: user,\n    programs,\n  });\n  const ownerTokenAddress =\n    params.ownerTokenAddress ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: owner.publicKey,\n      programs,\n    });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Revoke the use authority.\n      .add({\n        instruction: createRevokeUseAuthorityInstruction(\n          {\n            useAuthorityRecord,\n            owner: owner.publicKey,\n            user,\n            ownerTokenAccount: ownerTokenAddress,\n            mint: mintAddress,\n            metadata,\n            tokenProgram: tokenProgram.address,\n            systemProgram: systemProgram.address,\n          },\n          tokenMetadataProgram.address\n        ),\n        signers: [owner],\n        key: params.instructionKey ?? 'revokeUseAuthority',\n      })\n  );\n};\n","import {\n  VerificationArgs,\n  createVerifyInstruction,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'VerifyNftCreatorOperation' as const;\n\n/**\n * Verifies the creator of an NFT or SFT.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .verifyCreator({ mintAddress, creator };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const verifyNftCreatorOperation =\n  useOperation<VerifyNftCreatorOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type VerifyNftCreatorOperation = Operation<\n  typeof Key,\n  VerifyNftCreatorInput,\n  VerifyNftCreatorOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type VerifyNftCreatorInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /**\n   * The creator of the NFT or SFT as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  creator?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type VerifyNftCreatorOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const verifyNftCreatorOperationHandler: OperationHandler<VerifyNftCreatorOperation> =\n  {\n    handle: async (\n      operation: VerifyNftCreatorOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<VerifyNftCreatorOutput> => {\n      return verifyNftCreatorBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type VerifyNftCreatorBuilderParams = Omit<\n  VerifyNftCreatorInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that verifies the creator. */\n  instructionKey?: string;\n};\n\n/**\n * Verifies the creator of an NFT or SFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .verifyCreator({ mintAddress, creator });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const verifyNftCreatorBuilder = (\n  metaplex: Metaplex,\n  params: VerifyNftCreatorBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { mintAddress, creator = metaplex.identity() } = params;\n\n  // Programs.\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Verify the creator.\n      .add({\n        instruction: createVerifyInstruction(\n          {\n            authority: creator.publicKey,\n            metadata: metaplex.nfts().pdas().metadata({\n              mint: mintAddress,\n              programs,\n            }),\n            systemProgram: systemProgram.address,\n            sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n          },\n          { verificationArgs: VerificationArgs.CreatorV1 },\n          tokenMetadataProgram.address\n        ),\n        signers: [creator],\n        key: params.instructionKey ?? 'verifyCreator',\n      })\n  );\n};\n","import {\n  VerificationArgs,\n  createUnverifyInstruction,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UnverifyNftCreatorOperation' as const;\n\n/**\n * Unverifies the creator of an NFT or SFT.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .unverifyCreator({ mintAddress, creator };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const unverifyNftCreatorOperation =\n  useOperation<UnverifyNftCreatorOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UnverifyNftCreatorOperation = Operation<\n  typeof Key,\n  UnverifyNftCreatorInput,\n  UnverifyNftCreatorOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UnverifyNftCreatorInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /**\n   * The creator of the NFT or SFT as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  creator?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UnverifyNftCreatorOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const unverifyNftCreatorOperationHandler: OperationHandler<UnverifyNftCreatorOperation> =\n  {\n    handle: async (\n      operation: UnverifyNftCreatorOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<UnverifyNftCreatorOutput> => {\n      return unverifyNftCreatorBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UnverifyNftCreatorBuilderParams = Omit<\n  UnverifyNftCreatorInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that unverifies the creator. */\n  instructionKey?: string;\n};\n\n/**\n * Unverifies the creator of an NFT or SFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .unverifyCreator({ mintAddress, creator });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const unverifyNftCreatorBuilder = (\n  metaplex: Metaplex,\n  params: UnverifyNftCreatorBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { mintAddress, creator = metaplex.identity() } = params;\n\n  // Programs.\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Verify the creator.\n      .add({\n        instruction: createUnverifyInstruction(\n          {\n            authority: creator.publicKey,\n            metadata: metaplex.nfts().pdas().metadata({\n              mint: mintAddress,\n              programs,\n            }),\n            systemProgram: systemProgram.address,\n            sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n          },\n          { verificationArgs: VerificationArgs.CreatorV1 },\n          tokenMetadataProgram.address\n        ),\n        signers: [creator],\n        key: params.instructionKey ?? 'unverifyCreator',\n      })\n  );\n};\n","import {\n  VerificationArgs,\n  createVerifyCollectionInstruction,\n  createVerifyInstruction,\n  createVerifySizedCollectionItemInstruction,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'VerifyNftCollectionOperation' as const;\n\n/**\n * Verifies the collection of an NFT or SFT.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .verifyCollection({ mintAddress, collectionMintAddress };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const verifyNftCollectionOperation =\n  useOperation<VerifyNftCollectionOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type VerifyNftCollectionOperation = Operation<\n  typeof Key,\n  VerifyNftCollectionInput,\n  VerifyNftCollectionOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type VerifyNftCollectionInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The mint address of the collection NFT. */\n  collectionMintAddress: PublicKey;\n\n  /**\n   * An authority that can verify and unverify collection items\n   * from the provided `collectionMintAddress`.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  collectionAuthority?: Signer;\n\n  /**\n   * Whether or not the provided `collectionMintAddress` is a\n   * sized collection (as opposed to a legacy collection).\n   *\n   * @defaultValue `true`\n   */\n  isSizedCollection?: boolean;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority.\n   *\n   * - `false` means the collection authority is the update authority of the collection.\n   * - `legacyDelegate` means the collection authority is a delegate that was approved\n   *  using the legacy `metaplex.nfts().approveCollectionAuthority()` operation.\n   * - `metadataDelegate` means the collection authority is a delegate that was approved\n   *  using the new `metaplex.nfts().delegate()` operation.\n   * - `true` is equivalent to `legacyDelegate` for backwards compatibility.\n   *\n   * @defaultValue `false`\n   */\n  isDelegated?: boolean | 'legacyDelegate' | 'metadataDelegate';\n\n  /**\n   * The update authority of the Collection NFT.\n   *\n   * This is used to compute the metadata delegate record when\n   * `isDelegated` is equal to `\"metadataDelegate\"`.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  collectionUpdateAuthority?: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type VerifyNftCollectionOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const verifyNftCollectionOperationHandler: OperationHandler<VerifyNftCollectionOperation> =\n  {\n    handle: async (\n      operation: VerifyNftCollectionOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<VerifyNftCollectionOutput> => {\n      return verifyNftCollectionBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type VerifyNftCollectionBuilderParams = Omit<\n  VerifyNftCollectionInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that verifies the collection. */\n  instructionKey?: string;\n};\n\n/**\n * Verifies the collection of an NFT or SFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .verifyCollection({ mintAddress, collectionMintAddress });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const verifyNftCollectionBuilder = (\n  metaplex: Metaplex,\n  params: VerifyNftCollectionBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    collectionMintAddress,\n    isSizedCollection = true,\n    isDelegated = false,\n    collectionAuthority = metaplex.identity(),\n    collectionUpdateAuthority = metaplex.identity().publicKey,\n  } = params;\n\n  // Programs.\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  // Accounts.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const collectionMetadata = metaplex.nfts().pdas().metadata({\n    mint: collectionMintAddress,\n    programs,\n  });\n  const collectionEdition = metaplex.nfts().pdas().masterEdition({\n    mint: collectionMintAddress,\n    programs,\n  });\n\n  if (isDelegated === 'legacyDelegate' || isDelegated === true) {\n    const accounts = {\n      metadata,\n      collectionAuthority: collectionAuthority.publicKey,\n      payer: payer.publicKey,\n      collectionMint: collectionMintAddress,\n      collection: collectionMetadata,\n      collectionMasterEditionAccount: collectionEdition,\n    };\n    const instruction = isSizedCollection\n      ? createVerifySizedCollectionItemInstruction(\n          accounts,\n          tokenMetadataProgram.address\n        )\n      : createVerifyCollectionInstruction(\n          accounts,\n          tokenMetadataProgram.address\n        );\n    instruction.keys.push({\n      pubkey: metaplex.nfts().pdas().collectionAuthorityRecord({\n        mint: collectionMintAddress,\n        collectionAuthority: collectionAuthority.publicKey,\n        programs,\n      }),\n      isWritable: false,\n      isSigner: false,\n    });\n\n    return TransactionBuilder.make()\n      .setFeePayer(payer)\n      .add({\n        instruction,\n        signers: [payer, collectionAuthority],\n        key: params.instructionKey ?? 'verifyCollection',\n      });\n  }\n\n  const delegateRecord =\n    isDelegated === 'metadataDelegate'\n      ? metaplex.nfts().pdas().metadataDelegateRecord({\n          mint: collectionMintAddress,\n          type: 'CollectionV1',\n          updateAuthority: collectionUpdateAuthority,\n          delegate: collectionAuthority.publicKey,\n          programs,\n        })\n      : undefined;\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createVerifyInstruction(\n        {\n          authority: collectionAuthority.publicKey,\n          delegateRecord,\n          metadata,\n          collectionMint: collectionMintAddress,\n          collectionMetadata,\n          collectionMasterEdition: collectionEdition,\n          systemProgram: systemProgram.address,\n          sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n        },\n        { verificationArgs: VerificationArgs.CollectionV1 },\n        tokenMetadataProgram.address\n      ),\n      signers: [collectionAuthority],\n      key: params.instructionKey ?? 'verifyCollection',\n    });\n};\n","import {\n  VerificationArgs,\n  createUnverifyCollectionInstruction,\n  createUnverifyInstruction,\n  createUnverifySizedCollectionItemInstruction,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UnverifyNftCollectionOperation' as const;\n\n/**\n * Unverifies the collection of an NFT or SFT.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .unverifyCollection({ mintAddress, collectionMintAddress };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const unverifyNftCollectionOperation =\n  useOperation<UnverifyNftCollectionOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UnverifyNftCollectionOperation = Operation<\n  typeof Key,\n  UnverifyNftCollectionInput,\n  UnverifyNftCollectionOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UnverifyNftCollectionInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The mint address of the collection NFT. */\n  collectionMintAddress: PublicKey;\n\n  /**\n   * An authority that can verify and unverify collection items\n   * from the provided `collectionMintAddress`.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  collectionAuthority?: Signer;\n\n  /**\n   * Whether or not the provided `collectionMintAddress` is a\n   * sized collection (as opposed to a legacy collection).\n   *\n   * @defaultValue `true`\n   */\n  isSizedCollection?: boolean;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority.\n   *\n   * - `false` means the collection authority is the update authority of the collection.\n   * - `legacyDelegate` means the collection authority is a delegate that was approved\n   *  using the legacy `metaplex.nfts().approveCollectionAuthority()` operation.\n   * - `metadataDelegate` means the collection authority is a delegate that was approved\n   *  using the new `metaplex.nfts().delegate()` operation.\n   * - `true` is equivalent to `legacyDelegate` for backwards compatibility.\n   *\n   * @defaultValue `false`\n   */\n  isDelegated?: boolean | 'legacyDelegate' | 'metadataDelegate';\n\n  /**\n   * The update authority of the Collection NFT.\n   *\n   * This is used to compute the metadata delegate record when\n   * `isDelegated` is equal to `\"metadataDelegate\"`.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  collectionUpdateAuthority?: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UnverifyNftCollectionOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const unverifyNftCollectionOperationHandler: OperationHandler<UnverifyNftCollectionOperation> =\n  {\n    handle: async (\n      operation: UnverifyNftCollectionOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<UnverifyNftCollectionOutput> => {\n      return unverifyNftCollectionBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UnverifyNftCollectionBuilderParams = Omit<\n  UnverifyNftCollectionInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that unverifies the collection. */\n  instructionKey?: string;\n};\n\n/**\n * Unverifies the collection of an NFT or SFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .unverifyCollection({ mintAddress, collectionMintAddress });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const unverifyNftCollectionBuilder = (\n  metaplex: Metaplex,\n  params: UnverifyNftCollectionBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    collectionMintAddress,\n    isSizedCollection = true,\n    isDelegated = false,\n    collectionAuthority = metaplex.identity(),\n    collectionUpdateAuthority = metaplex.identity().publicKey,\n  } = params;\n\n  // Programs.\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  // Accounts.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const collectionMetadata = metaplex.nfts().pdas().metadata({\n    mint: collectionMintAddress,\n    programs,\n  });\n  const collectionEdition = metaplex.nfts().pdas().masterEdition({\n    mint: collectionMintAddress,\n    programs,\n  });\n\n  if (isDelegated === 'legacyDelegate' || isDelegated === true) {\n    const accounts = {\n      metadata,\n      collectionAuthority: collectionAuthority.publicKey,\n      payer: payer.publicKey,\n      collectionMint: collectionMintAddress,\n      collection: collectionMetadata,\n      collectionMasterEditionAccount: collectionEdition,\n      collectionAuthorityRecord: metaplex\n        .nfts()\n        .pdas()\n        .collectionAuthorityRecord({\n          mint: collectionMintAddress,\n          collectionAuthority: collectionAuthority.publicKey,\n          programs,\n        }),\n    };\n\n    const instruction = isSizedCollection\n      ? createUnverifySizedCollectionItemInstruction(\n          accounts,\n          tokenMetadataProgram.address\n        )\n      : createUnverifyCollectionInstruction(\n          accounts,\n          tokenMetadataProgram.address\n        );\n\n    return TransactionBuilder.make()\n      .setFeePayer(payer)\n      .add({\n        instruction,\n        signers: [payer, collectionAuthority],\n        key: params.instructionKey ?? 'unverifyCollection',\n      });\n  }\n\n  const delegateRecord =\n    isDelegated === 'metadataDelegate'\n      ? metaplex.nfts().pdas().metadataDelegateRecord({\n          mint: collectionMintAddress,\n          type: 'CollectionV1',\n          updateAuthority: collectionUpdateAuthority,\n          delegate: collectionAuthority.publicKey,\n          programs,\n        })\n      : undefined;\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createUnverifyInstruction(\n        {\n          authority: collectionAuthority.publicKey,\n          delegateRecord,\n          metadata,\n          collectionMint: collectionMintAddress,\n          collectionMetadata,\n          systemProgram: systemProgram.address,\n          sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n        },\n        { verificationArgs: VerificationArgs.CollectionV1 },\n        tokenMetadataProgram.address\n      ),\n      signers: [collectionAuthority],\n      key: params.instructionKey ?? 'unverifyCollection',\n    });\n};\n","import { createApproveCollectionAuthorityInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'ApproveNftCollectionAuthorityOperation' as const;\n\n/**\n * Approves a new collection authority.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .approveCollectionAuthority({\n *     mintAddress,\n *     collectionAuthority,\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const approveNftCollectionAuthorityOperation =\n  useOperation<ApproveNftCollectionAuthorityOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type ApproveNftCollectionAuthorityOperation = Operation<\n  typeof Key,\n  ApproveNftCollectionAuthorityInput,\n  ApproveNftCollectionAuthorityOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type ApproveNftCollectionAuthorityInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The address of the collection authority to approve. */\n  collectionAuthority: PublicKey;\n\n  /**\n   * The update authority of the NFT or SFT as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  updateAuthority?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type ApproveNftCollectionAuthorityOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const approveNftCollectionAuthorityOperationHandler: OperationHandler<ApproveNftCollectionAuthorityOperation> =\n  {\n    handle: async (\n      operation: ApproveNftCollectionAuthorityOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<ApproveNftCollectionAuthorityOutput> => {\n      return approveNftCollectionAuthorityBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type ApproveNftCollectionAuthorityBuilderParams = Omit<\n  ApproveNftCollectionAuthorityInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that approves the collection authority. */\n  instructionKey?: string;\n};\n\n/**\n * Approves a new collection authority.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .approveCollectionAuthority({\n *     mintAddress,\n *     collectionAuthority,\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const approveNftCollectionAuthorityBuilder = (\n  metaplex: Metaplex,\n  params: ApproveNftCollectionAuthorityBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    collectionAuthority,\n    updateAuthority = metaplex.identity(),\n  } = params;\n\n  // Programs.\n  const systemProgram = metaplex.programs().getSystem(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  // PDAs.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const collectionAuthorityRecord = metaplex\n    .nfts()\n    .pdas()\n    .collectionAuthorityRecord({\n      mint: mintAddress,\n      collectionAuthority,\n      programs,\n    });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Approve the collection authority.\n      .add({\n        instruction: createApproveCollectionAuthorityInstruction(\n          {\n            collectionAuthorityRecord,\n            newCollectionAuthority: collectionAuthority,\n            updateAuthority: updateAuthority.publicKey,\n            payer: payer.publicKey,\n            metadata,\n            mint: mintAddress,\n            systemProgram: systemProgram.address,\n          },\n          tokenMetadataProgram.address\n        ),\n        signers: [payer, updateAuthority],\n        key: params.instructionKey ?? 'approveCollectionAuthority',\n      })\n  );\n};\n","import { createRevokeCollectionAuthorityInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'RevokeNftCollectionAuthorityOperation' as const;\n\n/**\n * Revokes an existing collection authority.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .revokeCollectionAuthority({ mintAddress, collectionAuthority };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const revokeNftCollectionAuthorityOperation =\n  useOperation<RevokeNftCollectionAuthorityOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type RevokeNftCollectionAuthorityOperation = Operation<\n  typeof Key,\n  RevokeNftCollectionAuthorityInput,\n  RevokeNftCollectionAuthorityOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type RevokeNftCollectionAuthorityInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The address of the collection authority to revoke. */\n  collectionAuthority: PublicKey;\n\n  /**\n   * An authority that can revoke this collection authority.\n   *\n   * This can either be the collection's update authority or the delegated\n   * collection authority itself (i.e. revoking its own rights).\n   */\n  revokeAuthority?: Signer;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type RevokeNftCollectionAuthorityOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const revokeNftCollectionAuthorityOperationHandler: OperationHandler<RevokeNftCollectionAuthorityOperation> =\n  {\n    handle: async (\n      operation: RevokeNftCollectionAuthorityOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<RevokeNftCollectionAuthorityOutput> => {\n      return revokeNftCollectionAuthorityBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type RevokeNftCollectionAuthorityBuilderParams = Omit<\n  RevokeNftCollectionAuthorityInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that revokes the collection authority. */\n  instructionKey?: string;\n};\n\n/**\n * Revokes an existing collection authority.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .revokeCollectionAuthority({ mintAddress, collectionAuthority });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const revokeNftCollectionAuthorityBuilder = (\n  metaplex: Metaplex,\n  params: RevokeNftCollectionAuthorityBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    collectionAuthority,\n    revokeAuthority = metaplex.identity(),\n  } = params;\n\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const collectionAuthorityRecord = metaplex\n    .nfts()\n    .pdas()\n    .collectionAuthorityRecord({\n      mint: mintAddress,\n      collectionAuthority,\n      programs,\n    });\n\n  const instruction = createRevokeCollectionAuthorityInstruction(\n    {\n      collectionAuthorityRecord,\n      delegateAuthority: collectionAuthority,\n      revokeAuthority: revokeAuthority.publicKey,\n      metadata,\n      mint: mintAddress,\n    },\n    tokenMetadataProgram.address\n  );\n\n  // Temporary fix. The Shank macro wrongfully ask for the delegateAuthority to be a signer.\n  // https://github.com/metaplex-foundation/metaplex-program-library/pull/639\n  instruction.keys[1].isSigner = false;\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Revoke the collection authority.\n      .add({\n        instruction,\n        signers: [revokeAuthority],\n        key: params.instructionKey ?? 'revokeCollectionAuthority',\n      })\n  );\n};\n","import { createSetCollectionSizeInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  BigNumber,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'MigrateToSizedCollectionNftOperation' as const;\n\n/**\n * Migrates a legacy Collection NFT to a sized Collection NFT.\n * Both can act as a Collection for NFTs but only the latter\n * keeps track of the size of the collection on chain.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .migrateToSizedCollection({ mintAddress, size: toBigNumber(10000) };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const migrateToSizedCollectionNftOperation =\n  useOperation<MigrateToSizedCollectionNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type MigrateToSizedCollectionNftOperation = Operation<\n  typeof Key,\n  MigrateToSizedCollectionNftInput,\n  MigrateToSizedCollectionNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type MigrateToSizedCollectionNftInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /**\n   * An authority that can update the Collection NFT at the\n   * given mint address. This can either be the update authority\n   * for that Collection NFT or an approved delegate authority.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  collectionAuthority?: Signer;\n\n  /**\n   * The current size of all **verified** NFTs and/or SFTs within\n   * the Collection.\n   *\n   * **Warning, once set, this size can no longer be updated.**\n   */\n  size: BigNumber;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority\n   * using `metaplex.nfts().approveCollectionAuthority()`.\n   *\n   * @defaultValue `false`\n   */\n  isDelegated?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type MigrateToSizedCollectionNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const migrateToSizedCollectionNftOperationHandler: OperationHandler<MigrateToSizedCollectionNftOperation> =\n  {\n    handle: async (\n      operation: MigrateToSizedCollectionNftOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<MigrateToSizedCollectionNftOutput> => {\n      return migrateToSizedCollectionNftBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type MigrateToSizedCollectionNftBuilderParams = Omit<\n  MigrateToSizedCollectionNftInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that sets the collection size. */\n  instructionKey?: string;\n};\n\n/**\n * Migrates a legacy Collection NFT to a sized Collection NFT.\n * Both can act as a Collection for NFTs but only the latter\n * keeps track of the size of the collection on chain.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .migrateToSizedCollection({ mintAddress, size: toBigNumber(10000) });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const migrateToSizedCollectionNftBuilder = (\n  metaplex: Metaplex,\n  params: MigrateToSizedCollectionNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    collectionAuthority = metaplex.identity(),\n    size,\n    isDelegated = false,\n  } = params;\n\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const nftPdas = metaplex.nfts().pdas();\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update the metadata account.\n      .add({\n        instruction: createSetCollectionSizeInstruction(\n          {\n            collectionMetadata: nftPdas.metadata({\n              mint: mintAddress,\n              programs,\n            }),\n            collectionAuthority: collectionAuthority.publicKey,\n            collectionMint: mintAddress,\n            collectionAuthorityRecord: isDelegated\n              ? nftPdas.collectionAuthorityRecord({\n                  mint: mintAddress,\n                  collectionAuthority: collectionAuthority.publicKey,\n                  programs,\n                })\n              : undefined,\n          },\n          { setCollectionSizeArgs: { size } },\n          tokenMetadataProgram.address\n        ),\n        signers: [collectionAuthority],\n        key: params.instructionKey ?? 'setCollectionSize',\n      })\n  );\n};\n","import { createLockInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { isNonFungible, Sft } from '../models';\nimport {\n  parseTokenMetadataAuthorization,\n  TokenMetadataAuthorityTokenDelegate,\n  TokenMetadataAuthorizationDetails,\n} from '../Authorization';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\nconst TOKEN_AUTH_RULES_ID = new PublicKey(\n  'auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg'\n);\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'LockNftOperation' as const;\n\n/**\n * Lock a programmable NFT.\n *\n * ```ts\n * await metaplex.nfts().lock({ nftOrSft, authority });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const lockNftOperation = useOperation<LockNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type LockNftOperation = Operation<\n  typeof Key,\n  LockNftInput,\n  LockNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type LockNftInput = {\n  /**\n   * The NFT or SFT to lock.\n   * We only need its address and token standard.\n   *\n   * Note that locking only works for programmable assets.\n   */\n  nftOrSft: Pick<Sft, 'address' | 'tokenStandard'>;\n\n  /**\n   * An authority allowed to lock the asset.\n   *\n   * This must be a token delegate.\n   *\n   * @see {@link TokenMetadataAuthority}\n   * @defaultValue `metaplex.identity()`\n   */\n  authority: TokenMetadataAuthorityTokenDelegate;\n\n  /**\n   * The authorization rules and data to use for the operation.\n   *\n   * @see {@link TokenMetadataAuthorizationDetails}\n   * @defaultValue Defaults to not using auth rules.\n   */\n  authorizationDetails?: TokenMetadataAuthorizationDetails;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type LockNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const lockNftOperationHandler: OperationHandler<LockNftOperation> = {\n  handle: async (\n    operation: LockNftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ): Promise<LockNftOutput> => {\n    return lockNftBuilder(metaplex, operation.input, scope).sendAndConfirm(\n      metaplex,\n      scope.confirmOptions\n    );\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type LockNftBuilderParams = Omit<LockNftInput, 'confirmOptions'> & {\n  /** A key to distinguish the instruction that uses the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Lock a programmable NFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .lock({ nftOrSft, authority });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const lockNftBuilder = (\n  metaplex: Metaplex,\n  params: LockNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { nftOrSft } = params;\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const systemProgram = metaplex.programs().getSystem(programs);\n\n  // Auth.\n  const auth = parseTokenMetadataAuthorization(metaplex, {\n    mint: nftOrSft.address,\n    authority: params.authority,\n    authorizationDetails: params.authorizationDetails,\n    programs,\n  });\n\n  // PDAs.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: nftOrSft.address,\n    programs,\n  });\n  const edition = metaplex.nfts().pdas().masterEdition({\n    mint: nftOrSft.address,\n    programs,\n  });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update the metadata account.\n      .add({\n        instruction: createLockInstruction(\n          {\n            authority: auth.accounts.authority,\n            tokenOwner: auth.accounts.approver,\n            token: auth.accounts.token as PublicKey,\n            mint: nftOrSft.address,\n            metadata,\n            edition: isNonFungible(nftOrSft) ? edition : undefined,\n            tokenRecord: auth.accounts.delegateRecord,\n            payer: payer.publicKey,\n            systemProgram: systemProgram.address,\n            sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n            splTokenProgram: tokenProgram.address,\n            authorizationRules: auth.accounts.authorizationRules,\n            authorizationRulesProgram: TOKEN_AUTH_RULES_ID,\n          },\n          { lockArgs: { __kind: 'V1', ...auth.data } },\n          tokenMetadataProgram.address\n        ),\n        signers: [payer, ...auth.signers],\n        key: params.instructionKey ?? 'lockNft',\n      })\n  );\n};\n","import { createUnlockInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  parseTokenMetadataAuthorization,\n  TokenMetadataAuthorityTokenDelegate,\n  TokenMetadataAuthorizationDetails,\n} from '../Authorization';\nimport { isNonFungible, Sft } from '../models';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\nconst TOKEN_AUTH_RULES_ID = new PublicKey(\n  'auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg'\n);\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UnlockNftOperation' as const;\n\n/**\n * Unlock a programmable NFT.\n *\n * ```ts\n * await metaplex.nfts().unlock({ nftOrSft, authority });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const unlockNftOperation = useOperation<UnlockNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UnlockNftOperation = Operation<\n  typeof Key,\n  UnlockNftInput,\n  UnlockNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UnlockNftInput = {\n  /**\n   * The NFT or SFT to unlock.\n   * We only need its address and token standard.\n   *\n   * Note that locking and unlocking only works for programmable assets.\n   */\n  nftOrSft: Pick<Sft, 'address' | 'tokenStandard'>;\n\n  /**\n   * An authority allowed to unlock the asset.\n   *\n   * This must be a token delegate.\n   *\n   * @see {@link TokenMetadataAuthority}\n   * @defaultValue `metaplex.identity()`\n   */\n  authority: TokenMetadataAuthorityTokenDelegate;\n\n  /**\n   * The authorization rules and data to use for the operation.\n   *\n   * @see {@link TokenMetadataAuthorizationDetails}\n   * @defaultValue Defaults to not using auth rules.\n   */\n  authorizationDetails?: TokenMetadataAuthorizationDetails;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UnlockNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const unlockNftOperationHandler: OperationHandler<UnlockNftOperation> = {\n  handle: async (\n    operation: UnlockNftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ): Promise<UnlockNftOutput> => {\n    return unlockNftBuilder(metaplex, operation.input, scope).sendAndConfirm(\n      metaplex,\n      scope.confirmOptions\n    );\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type UnlockNftBuilderParams = Omit<UnlockNftInput, 'confirmOptions'> & {\n  /** A key to distinguish the instruction that uses the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Unlock a programmable NFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .unlock({ nftOrSft, authority });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const unlockNftBuilder = (\n  metaplex: Metaplex,\n  params: UnlockNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { nftOrSft } = params;\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const systemProgram = metaplex.programs().getSystem(programs);\n\n  // Auth.\n  const auth = parseTokenMetadataAuthorization(metaplex, {\n    mint: nftOrSft.address,\n    authority: params.authority,\n    authorizationDetails: params.authorizationDetails,\n    programs,\n  });\n\n  // PDAs.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: nftOrSft.address,\n    programs,\n  });\n  const edition = metaplex.nfts().pdas().masterEdition({\n    mint: nftOrSft.address,\n    programs,\n  });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update the metadata account.\n      .add({\n        instruction: createUnlockInstruction(\n          {\n            authority: auth.accounts.authority,\n            tokenOwner: auth.accounts.approver,\n            token: auth.accounts.token as PublicKey,\n            mint: nftOrSft.address,\n            metadata,\n            edition: isNonFungible(nftOrSft) ? edition : undefined,\n            tokenRecord: auth.accounts.delegateRecord,\n            payer: payer.publicKey,\n            systemProgram: systemProgram.address,\n            sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n            splTokenProgram: tokenProgram.address,\n            authorizationRules: auth.accounts.authorizationRules,\n            authorizationRulesProgram: TOKEN_AUTH_RULES_ID,\n          },\n          { unlockArgs: { __kind: 'V1', ...auth.data } },\n          tokenMetadataProgram.address\n        ),\n        signers: [payer, ...auth.signers],\n        key: params.instructionKey ?? 'UnlockNft',\n      })\n  );\n};\n","import { createMintInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  parseTokenMetadataAuthorization,\n  TokenMetadataAuthorityMetadata,\n  TokenMetadataAuthorizationDetails,\n} from '../Authorization';\nimport { isNonFungible, Sft } from '../models';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  token,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\nconst TOKEN_AUTH_RULES_ID = new PublicKey(\n  'auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg'\n);\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'MintNftOperation' as const;\n\n/**\n * Mint token(s) for an NFT or SFT.\n *\n * ```ts\n * await metaplex.nfts().mint({\n *   nftOrSft,\n *   toOwner,\n *   amount: token(5),\n * });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const mintNftOperation = useOperation<MintNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type MintNftOperation = Operation<\n  typeof Key,\n  MintNftInput,\n  MintNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type MintNftInput = {\n  /**\n   * The NFT or SFT to mint from.\n   * We only need its address and token standard.\n   */\n  nftOrSft: Pick<Sft, 'address' | 'tokenStandard'>;\n\n  /**\n   * An authority allowed to mint the asset.\n   *\n   * This must be the update authority for Non-Fungible assets\n   * and the mint authority for Semi-Fungible assets.\n   *\n   * Note that Delegate and Holder authorities\n   * are not supported for this instruction.\n   *\n   * @see {@link TokenMetadataAuthority}\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?: Signer | TokenMetadataAuthorityMetadata;\n\n  /**\n   * The authorization rules and data to use for the mint.\n   *\n   * @see {@link TokenMetadataAuthorizationDetails}\n   * @defaultValue Defaults to not using auth rules.\n   */\n  authorizationDetails?: TokenMetadataAuthorizationDetails;\n\n  /**\n   * The owner of the destination token account.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  toOwner?: PublicKey;\n\n  /**\n   * The address of the destination token account.\n   *\n   * This may be a regular token account or an associated token account.\n   * If the token account does not exist, then it will be created but\n   * only if it is an associated token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `nftOrSft.address` and `toOwner` parameters.\n   */\n  toToken?: PublicKey;\n\n  /**\n   * The amount of tokens to mint.\n   *\n   * @defaultValue `token(1)`\n   */\n  amount?: SplTokenAmount;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type MintNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const mintNftOperationHandler: OperationHandler<MintNftOperation> = {\n  handle: async (\n    operation: MintNftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ): Promise<MintNftOutput> => {\n    return mintNftBuilder(metaplex, operation.input, scope).sendAndConfirm(\n      metaplex,\n      scope.confirmOptions\n    );\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type MintNftBuilderParams = Omit<MintNftInput, 'confirmOptions'> & {\n  /** A key to distinguish the instruction that uses the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Mint token(s) for an NFT or SFT.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .mint({\n *     nftOrSft,\n *     toOwner,\n *     amount: token(5),\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const mintNftBuilder = (\n  metaplex: Metaplex,\n  params: MintNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    nftOrSft,\n    authority = metaplex.identity(),\n    authorizationDetails,\n    toOwner = metaplex.identity().publicKey,\n    amount = token(1),\n  } = params;\n\n  // Auth.\n  const auth = parseTokenMetadataAuthorization(metaplex, {\n    mint: nftOrSft.address,\n    authority:\n      '__kind' in authority\n        ? authority\n        : { __kind: 'metadata', updateAuthority: authority },\n    authorizationDetails,\n    programs,\n  });\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const ataProgram = metaplex.programs().getAssociatedToken(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const systemProgram = metaplex.programs().getSystem(programs);\n\n  // PDAs.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: nftOrSft.address,\n    programs,\n  });\n  const masterEdition = metaplex.nfts().pdas().masterEdition({\n    mint: nftOrSft.address,\n    programs,\n  });\n\n  // Destination token account.\n  const toToken =\n    params.toToken ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: nftOrSft.address,\n      owner: toOwner,\n      programs,\n    });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update the metadata account.\n      .add({\n        instruction: createMintInstruction(\n          {\n            token: toToken,\n            tokenOwner: toOwner,\n            metadata,\n            masterEdition: isNonFungible(nftOrSft) ? masterEdition : undefined,\n            tokenRecord: metaplex.nfts().pdas().tokenRecord({\n              mint: nftOrSft.address,\n              token: toToken,\n              programs,\n            }),\n            mint: nftOrSft.address,\n            authority: auth.accounts.authority,\n            // delegateRecord, // TODO: add when program supports Authority delegate.\n            payer: payer.publicKey,\n            systemProgram: systemProgram.address,\n            sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n            splTokenProgram: tokenProgram.address,\n            splAtaProgram: ataProgram.address,\n            authorizationRules: auth.accounts.authorizationRules,\n            authorizationRulesProgram: TOKEN_AUTH_RULES_ID,\n          },\n          {\n            mintArgs: {\n              __kind: 'V1',\n              amount: amount.basisPoints,\n              ...auth.data,\n            },\n          },\n          tokenMetadataProgram.address\n        ),\n        signers: [payer, ...auth.signers],\n        key: params.instructionKey ?? 'mintNft',\n      })\n  );\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { createTransferInstruction } from '@metaplex-foundation/mpl-bubblegum';\nimport {\n  MerkleTree,\n  ConcurrentMerkleTreeAccount,\n  SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,\n  SPL_NOOP_PROGRAM_ID,\n} from '@solana/spl-account-compression';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  TokenMetadataAuthorityHolder,\n  TokenMetadataAuthorityTokenDelegate,\n  TokenMetadataAuthorizationDetails,\n} from '../Authorization';\nimport { Sft } from '../models';\nimport { Metaplex } from '@/Metaplex';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  GetAssetProofRpcResponse,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  useOperation,\n  TransferNftCompressionParam,\n  ReadApiAsset,\n} from '@/types';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'TransferCompressedNftOperation' as const;\n\n/**\n * Transfers a compressed NFT or SFT from one account to another.\n *\n * ```ts\n * await metaplex.nfts().transfer({\n *   nftOrSft,\n *   toOwner,\n * });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const transferCompressedNftOperation =\n  useOperation<TransferCompressedNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type TransferCompressedNftOperation = Operation<\n  typeof Key,\n  TransferCompressedNftInput,\n  TransferCompressedNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type TransferCompressedNftInput = {\n  /**\n   * The compressed NFT or SFT to transfer.\n   * We only need its address and token standard.\n   */\n  nftOrSft: Sft;\n\n  /**\n   * An authority allowed to transfer the asset.\n   *\n   * Note that Metadata authorities are\n   * not supported for this instruction.\n   *\n   * If a `Signer` is provided directly,\n   * it will be used as an Holder authority.\n   *\n   * @see {@link TokenMetadataAuthority}\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?:\n    | Signer\n    | TokenMetadataAuthorityTokenDelegate\n    | TokenMetadataAuthorityHolder;\n\n  /**\n   * The authorization rules and data to use for the transfer.\n   *\n   * @see {@link TokenMetadataAuthorizationDetails}\n   * @defaultValue Defaults to not using auth rules.\n   */\n  authorizationDetails?: TokenMetadataAuthorizationDetails;\n\n  /**\n   * The wallet to get the tokens from.\n   *\n   * @defaultValue The public key of the provided authority.\n   */\n  fromOwner?: PublicKey;\n\n  /**\n   * The token account to be debited.\n   *\n   * @defaultValue Defaults to the associated token account of `fromOwner`.\n   */\n  fromToken?: PublicKey;\n\n  /**\n   * The wallet to send the tokens to.\n   */\n  toOwner: PublicKey;\n\n  /**\n   * The token account to be credited.\n   *\n   * @defaultValue Defaults to the associated token account of `toOwner`.\n   */\n  toToken?: PublicKey;\n\n  /**\n   * The amount of tokens to transfer.\n   *\n   * @defaultValue `token(1)`\n   */\n  amount?: SplTokenAmount;\n\n  /**\n   * The compression data needed for transfer.\n   * Including the assetProof, concurrent merkle tree account info, and compression metadata.\n   */\n  compression: TransferNftCompressionParam;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type TransferCompressedNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const transferCompressedNftOperationHandler: OperationHandler<TransferCompressedNftOperation> =\n  {\n    handle: async (\n      operation: TransferCompressedNftOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<TransferCompressedNftOutput> => {\n      return transferCompressedNftBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type TransferCompressedNftBuilderParams = Omit<\n  TransferCompressedNftInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that uses the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Transfers a compressed NFT from one account to another.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .transfer({\n *     nftOrSft,\n *     toOwner,\n *     compression,\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const transferCompressedNftBuilder = (\n  metaplex: Metaplex,\n  params: TransferCompressedNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { toOwner, compression } = params;\n\n  // ensure all required compression data has been supplied\n  if (\n    !compression.merkleTree ||\n    !compression.assetProof ||\n    !compression.data ||\n    !compression.ownership\n  )\n    throw Error('Invalid compression data supplied');\n\n  const merkleTree = new PublicKey(compression.assetProof.tree_id);\n  const treeAuthority = compression.merkleTree?.getAuthority();\n  const canopyDepth = compression.merkleTree?.getCanopyDepth();\n\n  const leafOwner = new PublicKey(compression.ownership.owner);\n  const leafDelegate = !!compression.ownership?.delegate\n    ? new PublicKey(compression.ownership.delegate)\n    : leafOwner;\n\n  // check if the provided assetProof path is valid for the provided root\n  if (\n    !MerkleTree.verify(new PublicKey(compression.assetProof.root).toBuffer(), {\n      leafIndex: compression.data.leaf_id,\n      leaf: new PublicKey(compression.assetProof.leaf).toBuffer(),\n      root: new PublicKey(compression.assetProof.root).toBuffer(),\n      proof: compression.assetProof.proof.map((node: string) =>\n        new PublicKey(node).toBuffer()\n      ),\n    })\n  )\n    throw Error('Provided proof path did not pass verification');\n\n  // parse the list of proof addresses into a valid AccountMeta[]\n  const proofPath = compression.assetProof.proof\n    .map((node: string) => ({\n      pubkey: new PublicKey(node),\n      isSigner: false,\n      isWritable: false,\n    }))\n    .slice(\n      0,\n      compression.assetProof.proof.length - (!!canopyDepth ? canopyDepth : 0)\n    );\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createTransferInstruction(\n        {\n          merkleTree,\n          treeAuthority,\n          leafOwner,\n          leafDelegate,\n          newLeafOwner: toOwner,\n          logWrapper: SPL_NOOP_PROGRAM_ID,\n          compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,\n          anchorRemainingAccounts: proofPath,\n        },\n        {\n          root: [\n            ...new PublicKey(compression.assetProof.root.trim()).toBytes(),\n          ],\n          dataHash: [\n            ...new PublicKey(compression.data.data_hash.trim()).toBytes(),\n          ],\n          creatorHash: [\n            ...new PublicKey(compression.data.creator_hash.trim()).toBytes(),\n          ],\n          nonce: compression.data.leaf_id,\n          index: compression.data.leaf_id,\n        }\n      ),\n      signers: [payer],\n      key: params.instructionKey ?? 'transferCompressedNft',\n    });\n};\n\n/**\n * Helper function to auto fetch the asset proof data from the ReadApi\n */\nexport async function prepareTransferCompressedNftBuilder(\n  metaplex: Metaplex,\n  params: TransferCompressedNftBuilderParams\n): Promise<TransferCompressedNftBuilderParams> {\n  if (!params?.compression) params.compression = {};\n\n  // auto fetch the assetProof data from the ReadApi, when not provided\n  if (!params?.compression?.assetProof) {\n    params.compression.assetProof = (await metaplex\n      .rpc()\n      .getAssetProof(params.nftOrSft.address)) as GetAssetProofRpcResponse;\n  }\n\n  const [asset, merkleTree] = await Promise.all([\n    // get the asset from the ReadApi\n    metaplex.rpc().getAsset(params.nftOrSft.address),\n\n    // get the on-chain merkle tree AccountInfo (mainly needed for the `canopyHeight`)\n    ConcurrentMerkleTreeAccount.fromAccountAddress(\n      metaplex.connection,\n      new PublicKey(params.compression.assetProof.tree_id)\n    ),\n  ]);\n\n  // update the params data for use by the transfer operation\n  params.compression.merkleTree = merkleTree;\n  params.compression.data = (asset as ReadApiAsset).compression;\n  params.compression.ownership = (asset as ReadApiAsset).ownership;\n\n  return params as TransferCompressedNftBuilderParams;\n}\n","import { createTransferInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey, SYSVAR_INSTRUCTIONS_PUBKEY } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport {\n  getSignerFromTokenMetadataAuthority,\n  parseTokenMetadataAuthorization,\n  TokenMetadataAuthorityHolder,\n  TokenMetadataAuthorityTokenDelegate,\n  TokenMetadataAuthorizationDetails,\n} from '../Authorization';\nimport { isNonFungible, isProgrammable, Sft } from '../models';\nimport {\n  TransferCompressedNftBuilderParams,\n  prepareTransferCompressedNftBuilder,\n  transferCompressedNftBuilder,\n} from './transferCompressedNft';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  token,\n  useOperation,\n  TransferNftCompressionParam,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\nconst TOKEN_AUTH_RULES_ID = new PublicKey(\n  'auth9SigNpDKz4sJJ1DfCTuZrZNSAgh9sFD3rboVmgg'\n);\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'TransferNftOperation' as const;\n\n/**\n * Transfers an NFT or SFT from one account to another.\n *\n * ```ts\n * await metaplex.nfts().transfer({\n *   nftOrSft,\n *   toOwner,\n *   amount: token(5),\n * });\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const transferNftOperation = useOperation<TransferNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type TransferNftOperation = Operation<\n  typeof Key,\n  TransferNftInput,\n  TransferNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type TransferNftInput = {\n  /**\n   * The NFT or SFT to transfer.\n   * We only need its address and token standard.\n   */\n  nftOrSft: Pick<Sft, 'address' | 'tokenStandard'>;\n\n  /**\n   * An authority allowed to transfer the asset.\n   *\n   * Note that Metadata authorities are\n   * not supported for this instruction.\n   *\n   * If a `Signer` is provided directly,\n   * it will be used as an Holder authority.\n   *\n   * @see {@link TokenMetadataAuthority}\n   * @defaultValue `metaplex.identity()`\n   */\n  authority?:\n    | Signer\n    | TokenMetadataAuthorityTokenDelegate\n    | TokenMetadataAuthorityHolder;\n\n  /**\n   * The authorization rules and data to use for the transfer.\n   *\n   * @see {@link TokenMetadataAuthorizationDetails}\n   * @defaultValue Defaults to not using auth rules.\n   */\n  authorizationDetails?: TokenMetadataAuthorizationDetails;\n\n  /**\n   * The wallet to get the tokens from.\n   *\n   * @defaultValue The public key of the provided authority.\n   */\n  fromOwner?: PublicKey;\n\n  /**\n   * The token account to be debited.\n   *\n   * @defaultValue Defaults to the associated token account of `fromOwner`.\n   */\n  fromToken?: PublicKey;\n\n  /**\n   * The wallet to send the tokens to.\n   */\n  toOwner: PublicKey;\n\n  /**\n   * The token account to be credited.\n   *\n   * @defaultValue Defaults to the associated token account of `toOwner`.\n   */\n  toToken?: PublicKey;\n\n  /**\n   * The amount of tokens to transfer.\n   *\n   * @defaultValue `token(1)`\n   */\n  amount?: SplTokenAmount;\n\n  /**\n   * The compression data needed for transfer.\n   */\n  compression?: TransferNftCompressionParam;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type TransferNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const transferNftOperationHandler: OperationHandler<TransferNftOperation> =\n  {\n    handle: async (\n      operation: TransferNftOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<TransferNftOutput> => {\n      // handle the case of transferring compressed nfts\n      if (\n        !!operation.input.compression ||\n        // @ts-ignore\n        !!operation.input.nftOrSft?.compression?.compressed\n      ) {\n        operation.input = await prepareTransferCompressedNftBuilder(\n          metaplex,\n          operation.input as TransferCompressedNftBuilderParams\n        );\n        return transferCompressedNftBuilder(\n          metaplex,\n          operation.input as TransferCompressedNftBuilderParams,\n          scope\n        ).sendAndConfirm(metaplex, scope.confirmOptions);\n      }\n\n      return transferNftBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type TransferNftBuilderParams = Omit<\n  TransferNftInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that uses the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Transfers an NFT or SFT from one account to another.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .transfer({\n *     nftOrSft,\n *     toOwner,\n *     amount: token(5),\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const transferNftBuilder = (\n  metaplex: Metaplex,\n  params: TransferNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    nftOrSft,\n    authority = metaplex.identity(),\n    toOwner,\n    amount = token(1),\n    authorizationDetails,\n  } = params;\n\n  // From owner.\n  const fromOwner =\n    params.fromOwner ??\n    getSignerFromTokenMetadataAuthority(authority).publicKey;\n\n  // Programs.\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const ataProgram = metaplex.programs().getAssociatedToken(programs);\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const systemProgram = metaplex.programs().getSystem(programs);\n\n  // PDAs.\n  const metadata = metaplex.nfts().pdas().metadata({\n    mint: nftOrSft.address,\n    programs,\n  });\n  const edition = metaplex.nfts().pdas().masterEdition({\n    mint: nftOrSft.address,\n    programs,\n  });\n  const fromToken =\n    params.fromToken ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: nftOrSft.address,\n      owner: fromOwner,\n      programs,\n    });\n  const toToken =\n    params.toToken ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: nftOrSft.address,\n      owner: toOwner,\n      programs,\n    });\n  const ownerTokenRecord = metaplex.nfts().pdas().tokenRecord({\n    mint: nftOrSft.address,\n    token: fromToken,\n    programs,\n  });\n  const destinationTokenRecord = metaplex.nfts().pdas().tokenRecord({\n    mint: nftOrSft.address,\n    token: toToken,\n    programs,\n  });\n\n  // Auth.\n  const auth = parseTokenMetadataAuthorization(metaplex, {\n    mint: nftOrSft.address,\n    authority:\n      '__kind' in authority\n        ? authority\n        : { __kind: 'holder', owner: authority, token: fromToken },\n    authorizationDetails,\n    programs,\n  });\n\n  return (\n    TransactionBuilder.make()\n      .setFeePayer(payer)\n\n      // Update the metadata account.\n      .add({\n        instruction: createTransferInstruction(\n          {\n            token: fromToken,\n            tokenOwner: fromOwner,\n            destination: toToken,\n            destinationOwner: toOwner,\n            mint: nftOrSft.address,\n            metadata,\n            edition: isNonFungible(nftOrSft) ? edition : undefined,\n            ownerTokenRecord: isProgrammable(nftOrSft)\n              ? ownerTokenRecord\n              : undefined,\n            destinationTokenRecord: isProgrammable(nftOrSft)\n              ? destinationTokenRecord\n              : undefined,\n            authority: auth.accounts.authority,\n            payer: payer.publicKey,\n            systemProgram: systemProgram.address,\n            sysvarInstructions: SYSVAR_INSTRUCTIONS_PUBKEY,\n            splTokenProgram: tokenProgram.address,\n            splAtaProgram: ataProgram.address,\n            authorizationRules: auth.accounts.authorizationRules,\n            authorizationRulesProgram: TOKEN_AUTH_RULES_ID,\n          },\n          {\n            transferArgs: {\n              __kind: 'V1',\n              amount: amount.basisPoints,\n              ...auth.data,\n            },\n          },\n          tokenMetadataProgram.address\n        ),\n        signers: [payer, ...auth.signers],\n        key: params.instructionKey ?? 'transferNft',\n      })\n  );\n};\n","import { createFreezeDelegatedAccountInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FreezeDelegatedNftOperation' as const;\n\n/**\n * Freezes a NFT via its delegate authority.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .freezeDelegatedNft({ mintAddress, delegateAuthority };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const freezeDelegatedNftOperation =\n  useOperation<FreezeDelegatedNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FreezeDelegatedNftOperation = Operation<\n  typeof Key,\n  FreezeDelegatedNftInput,\n  FreezeDelegatedNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FreezeDelegatedNftInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /**\n   * The SPL Token delegate authority.\n   *\n   * This authority should have been approved using\n   * `metaplex.tokens().approveDelegateAuthority()` beforehand.\n   */\n  delegateAuthority: Signer;\n\n  /**\n   * The owner of the token account.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * The address of the token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `tokenOwner` parameters.\n   */\n  tokenAddress?: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type FreezeDelegatedNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const freezeDelegatedNftOperationHandler: OperationHandler<FreezeDelegatedNftOperation> =\n  {\n    async handle(\n      operation: FreezeDelegatedNftOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<FreezeDelegatedNftOutput> {\n      return freezeDelegatedNftBuilder(\n        metaplex,\n        operation.input,\n        scope\n      ).sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type FreezeDelegatedNftBuilderParams = Omit<\n  FreezeDelegatedNftInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that freezes the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Freezes a NFT via its delegate authority.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .freezeDelegatedNft({ mintAddress, delegateAuthority });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const freezeDelegatedNftBuilder = (\n  metaplex: Metaplex,\n  params: FreezeDelegatedNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    delegateAuthority,\n    tokenOwner = metaplex.identity().publicKey,\n    tokenAddress,\n  } = params;\n\n  // Programs.\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  // PDAs.\n  const editionAddress = metaplex.nfts().pdas().masterEdition({\n    mint: mintAddress,\n    programs,\n  });\n  const tokenAddressOrAta =\n    tokenAddress ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: tokenOwner,\n      programs,\n    });\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createFreezeDelegatedAccountInstruction(\n        {\n          delegate: delegateAuthority.publicKey,\n          tokenAccount: tokenAddressOrAta,\n          edition: editionAddress,\n          mint: mintAddress,\n          tokenProgram: tokenProgram.address,\n        },\n        tokenMetadataProgram.address\n      ),\n      signers: [delegateAuthority],\n      key: params.instructionKey ?? 'freezeDelegatedNft',\n    });\n};\n","import { createThawDelegatedAccountInstruction } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'ThawDelegatedNftOperation' as const;\n\n/**\n * Thaws a NFT via its delegate authority.\n *\n * ```ts\n * await metaplex\n *   .nfts()\n *   .thawDelegatedNft({ mintAddress, delegateAuthority };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const thawDelegatedNftOperation =\n  useOperation<ThawDelegatedNftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type ThawDelegatedNftOperation = Operation<\n  typeof Key,\n  ThawDelegatedNftInput,\n  ThawDelegatedNftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type ThawDelegatedNftInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /**\n   * The SPL Token delegate authority.\n   *\n   * This authority should have been approved using\n   * `metaplex.tokens().approveDelegateAuthority()` beforehand.\n   */\n  delegateAuthority: Signer;\n\n  /**\n   * The owner of the token account.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * The address of the token account.\n   *\n   * @defaultValue Defaults to using the associated token account\n   * from the `mintAddress` and `tokenOwner` parameters.\n   */\n  tokenAddress?: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type ThawDelegatedNftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const thawDelegatedNftOperationHandler: OperationHandler<ThawDelegatedNftOperation> =\n  {\n    async handle(\n      operation: ThawDelegatedNftOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<ThawDelegatedNftOutput> {\n      return thawDelegatedNftBuilder(metaplex, operation.input).sendAndConfirm(\n        metaplex,\n        scope.confirmOptions\n      );\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type ThawDelegatedNftBuilderParams = Omit<\n  ThawDelegatedNftInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that thaws the NFT. */\n  instructionKey?: string;\n};\n\n/**\n * Thaws a NFT via its delegate authority.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .nfts()\n *   .builders()\n *   .thawDelegatedNft({ mintAddress, delegateAuthority });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const thawDelegatedNftBuilder = (\n  metaplex: Metaplex,\n  params: ThawDelegatedNftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAddress,\n    delegateAuthority,\n    tokenOwner = metaplex.identity().publicKey,\n    tokenAddress,\n  } = params;\n\n  // Programs.\n  const tokenProgram = metaplex.programs().getToken(programs);\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n\n  const editionAddress = metaplex.nfts().pdas().masterEdition({\n    mint: mintAddress,\n    programs,\n  });\n  const tokenAddressOrAta =\n    tokenAddress ??\n    metaplex.tokens().pdas().associatedTokenAccount({\n      mint: mintAddress,\n      owner: tokenOwner,\n      programs,\n    });\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: createThawDelegatedAccountInstruction(\n        {\n          delegate: delegateAuthority.publicKey,\n          tokenAccount: tokenAddressOrAta,\n          edition: editionAddress,\n          mint: mintAddress,\n          tokenProgram: tokenProgram.address,\n        },\n        tokenMetadataProgram.address\n      ),\n      signers: [delegateAuthority],\n      key: params.instructionKey ?? 'thawDelegatedNft',\n    });\n};\n","import {\n  approveNftCollectionAuthorityBuilder,\n  ApproveNftCollectionAuthorityBuilderParams,\n  approveNftDelegateBuilder,\n  ApproveNftDelegateBuilderParams,\n  approveNftUseAuthorityBuilder,\n  ApproveNftUseAuthorityBuilderParams,\n  createNftBuilder,\n  CreateNftBuilderParams,\n  createSftBuilder,\n  CreateSftBuilderParams,\n  deleteNftBuilder,\n  DeleteNftBuilderParams,\n  freezeDelegatedNftBuilder,\n  FreezeDelegatedNftBuilderParams,\n  lockNftBuilder,\n  LockNftBuilderParams,\n  migrateToSizedCollectionNftBuilder,\n  MigrateToSizedCollectionNftBuilderParams,\n  mintNftBuilder,\n  MintNftBuilderParams,\n  printNewEditionBuilder,\n  PrintNewEditionBuilderParams,\n  revokeNftCollectionAuthorityBuilder,\n  RevokeNftCollectionAuthorityBuilderParams,\n  revokeNftDelegateBuilder,\n  RevokeNftDelegateBuilderParams,\n  revokeNftUseAuthorityBuilder,\n  RevokeNftUseAuthorityBuilderParams,\n  thawDelegatedNftBuilder,\n  ThawDelegatedNftBuilderParams,\n  transferNftBuilder,\n  TransferNftBuilderParams,\n  unlockNftBuilder,\n  UnlockNftBuilderParams,\n  unverifyNftCollectionBuilder,\n  UnverifyNftCollectionBuilderParams,\n  unverifyNftCreatorBuilder,\n  UnverifyNftCreatorBuilderParams,\n  updateNftBuilder,\n  UpdateNftBuilderParams,\n  useNftBuilder,\n  UseNftBuilderParams,\n  verifyNftCollectionBuilder,\n  VerifyNftCollectionBuilderParams,\n  verifyNftCreatorBuilder,\n  VerifyNftCreatorBuilderParams,\n} from './operations';\nimport type { Metaplex } from '@/Metaplex';\nimport { TransactionBuilderOptions } from '@/utils';\n\n/**\n * This client allows you to access the underlying Transaction Builders\n * for the write operations of the NFT module.\n *\n * @see {@link NftClient}\n * @group Module Builders\n * */\nexport class NftBuildersClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  // -----------------\n  // Create, Update and Delete\n  // -----------------\n\n  /** {@inheritDoc createNftBuilder} */\n  create(input: CreateNftBuilderParams, options?: TransactionBuilderOptions) {\n    return createNftBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc createSftBuilder} */\n  createSft(\n    input: CreateSftBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return createSftBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc printNewEditionBuilder} */\n  printNewEdition(\n    input: PrintNewEditionBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return printNewEditionBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc updateNftBuilder} */\n  update(input: UpdateNftBuilderParams, options?: TransactionBuilderOptions) {\n    return updateNftBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc deleteNftBuilder} */\n  delete(input: DeleteNftBuilderParams, options?: TransactionBuilderOptions) {\n    return deleteNftBuilder(this.metaplex, input, options);\n  }\n\n  // -----------------\n  // Delegates\n  // -----------------\n\n  /** {@inheritDoc approveNftDelegateBuilder} */\n  delegate(\n    input: ApproveNftDelegateBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return approveNftDelegateBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc revokeNftDelegateBuilder} */\n  revoke(\n    input: RevokeNftDelegateBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return revokeNftDelegateBuilder(this.metaplex, input, options);\n  }\n\n  // -----------------\n  // Use\n  // -----------------\n\n  /** {@inheritDoc useNftBuilder} */\n  use(input: UseNftBuilderParams, options?: TransactionBuilderOptions) {\n    return useNftBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc approveNftUseAuthorityBuilder} */\n  approveUseAuthority(\n    input: ApproveNftUseAuthorityBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return approveNftUseAuthorityBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc revokeNftUseAuthorityBuilder} */\n  revokeUseAuthority(\n    input: RevokeNftUseAuthorityBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return revokeNftUseAuthorityBuilder(this.metaplex, input, options);\n  }\n\n  // -----------------\n  // Creators\n  // -----------------\n\n  /** {@inheritDoc verifyNftCreatorBuilder} */\n  verifyCreator(\n    input: VerifyNftCreatorBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return verifyNftCreatorBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc unverifyNftCreatorBuilder} */\n  unverifyCreator(\n    input: UnverifyNftCreatorBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return unverifyNftCreatorBuilder(this.metaplex, input, options);\n  }\n\n  // -----------------\n  // Collections\n  // -----------------\n\n  /** {@inheritDoc verifyNftCollectionBuilder} */\n  verifyCollection(\n    input: VerifyNftCollectionBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return verifyNftCollectionBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc unverifyNftCollectionBuilder} */\n  unverifyCollection(\n    input: UnverifyNftCollectionBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return unverifyNftCollectionBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc approveNftCollectionAuthorityBuilder} */\n  approveCollectionAuthority(\n    input: ApproveNftCollectionAuthorityBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return approveNftCollectionAuthorityBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc revokeNftCollectionAuthorityBuilder} */\n  revokeCollectionAuthority(\n    input: RevokeNftCollectionAuthorityBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return revokeNftCollectionAuthorityBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc migrateToSizedCollectionNftBuilder} */\n  migrateToSizedCollection(\n    input: MigrateToSizedCollectionNftBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return migrateToSizedCollectionNftBuilder(this.metaplex, input, options);\n  }\n\n  // -----------------\n  // Programmables\n  // -----------------\n\n  /** {@inheritDoc lockNftBuilder} */\n  lock(input: LockNftBuilderParams, options?: TransactionBuilderOptions) {\n    return lockNftBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc unlockNftBuilder} */\n  unlock(input: UnlockNftBuilderParams, options?: TransactionBuilderOptions) {\n    return unlockNftBuilder(this.metaplex, input, options);\n  }\n\n  // -----------------\n  // Token\n  // -----------------\n\n  /** {@inheritDoc mintNftBuilder} */\n  mint(input: MintNftBuilderParams, options?: TransactionBuilderOptions) {\n    return mintNftBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc transferNftBuilder} */\n  transfer(\n    input: TransferNftBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return transferNftBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc freezeDelegatedNftBuilder} */\n  freezeDelegatedNft(\n    input: FreezeDelegatedNftBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return freezeDelegatedNftBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc thawDelegatedNftBuilder} */\n  thawDelegatedNft(\n    input: ThawDelegatedNftBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return thawDelegatedNftBuilder(this.metaplex, input, options);\n  }\n}\n","import { Buffer } from 'buffer';\nimport {\n  MetadataDelegateType,\n  getMetadataDelegateRoleSeed,\n} from './DelegateType';\nimport type { Metaplex } from '@/Metaplex';\nimport { BigNumber, Pda, Program, PublicKey, toBigNumber } from '@/types';\n\n/**\n * This client allows you to build PDAs related to the NFT module.\n *\n * @see {@link NftClient}\n * @group Module Pdas\n */\nexport class NftPdasClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /** Finds the Metadata PDA of a given mint address. */\n  metadata({ mint, programs }: MintAddressPdaInput): Pda {\n    const programId = this.programId(programs);\n    return Pda.find(programId, [\n      Buffer.from('metadata', 'utf8'),\n      programId.toBuffer(),\n      mint.toBuffer(),\n    ]);\n  }\n\n  /** Finds the Master Edition PDA of a given mint address. */\n  masterEdition({ mint, programs }: MintAddressPdaInput): Pda {\n    const programId = this.programId(programs);\n    return Pda.find(programId, [\n      Buffer.from('metadata', 'utf8'),\n      programId.toBuffer(),\n      mint.toBuffer(),\n      Buffer.from('edition', 'utf8'),\n    ]);\n  }\n\n  /** Finds the Edition PDA of a given mint address. */\n  edition(input: MintAddressPdaInput): Pda {\n    return this.masterEdition(input);\n  }\n\n  /** Finds the Edition Marker PDA of a given edition number. */\n  editionMarker({\n    mint,\n    edition,\n    programs,\n  }: {\n    /** The address of the mint account of the edition NFT. */\n    mint: PublicKey;\n    /** The edition number of the NFT. */\n    edition: BigNumber;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const programId = this.programId(programs);\n    return Pda.find(programId, [\n      Buffer.from('metadata', 'utf8'),\n      programId.toBuffer(),\n      mint.toBuffer(),\n      Buffer.from('edition', 'utf8'),\n      Buffer.from(edition.div(toBigNumber(248)).toString()),\n    ]);\n  }\n\n  /** Finds the collection authority PDA for a given NFT and authority. */\n  collectionAuthorityRecord({\n    mint,\n    collectionAuthority,\n    programs,\n  }: {\n    /** The address of the NFT's mint account. */\n    mint: PublicKey;\n    /** The address of the collection authority. */\n    collectionAuthority: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const programId = this.programId(programs);\n    return Pda.find(programId, [\n      Buffer.from('metadata', 'utf8'),\n      programId.toBuffer(),\n      mint.toBuffer(),\n      Buffer.from('collection_authority', 'utf8'),\n      collectionAuthority.toBuffer(),\n    ]);\n  }\n\n  /** Finds the use authority PDA for a given NFT and user. */\n  useAuthorityRecord({\n    mint,\n    useAuthority,\n    programs,\n  }: {\n    /** The address of the NFT's mint account. */\n    mint: PublicKey;\n    /** The address of the use authority. */\n    useAuthority: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const programId = this.programId(programs);\n    return Pda.find(programId, [\n      Buffer.from('metadata', 'utf8'),\n      programId.toBuffer(),\n      mint.toBuffer(),\n      Buffer.from('user', 'utf8'),\n      useAuthority.toBuffer(),\n    ]);\n  }\n\n  /** Finds the burner PDA of the Token Metadata program. */\n  burner({\n    programs,\n  }: {\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const programId = this.programId(programs);\n    return Pda.find(programId, [\n      Buffer.from('metadata', 'utf8'),\n      programId.toBuffer(),\n      Buffer.from('burn', 'utf8'),\n    ]);\n  }\n\n  /** Finds the record PDA for a given NFT and delegate authority. */\n  tokenRecord(input: {\n    /** The address of the NFT's mint account. */\n    mint: PublicKey;\n    /** The address of the token account */\n    token: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const programId = this.programId(input.programs);\n    return Pda.find(programId, [\n      Buffer.from('metadata', 'utf8'),\n      programId.toBuffer(),\n      input.mint.toBuffer(),\n      Buffer.from('token_record', 'utf8'),\n      input.token.toBuffer(),\n    ]);\n  }\n\n  /** Finds the record PDA for a given NFT and delegate authority. */\n  metadataDelegateRecord(input: {\n    /** The address of the NFT's mint account. */\n    mint: PublicKey;\n    /** The role of the delegate authority. */\n    type: MetadataDelegateType;\n    /** The address of the metadata's update authority. */\n    updateAuthority: PublicKey;\n    /** The address of delegate authority. */\n    delegate: PublicKey;\n    /** An optional set of programs that override the registered ones. */\n    programs?: Program[];\n  }): Pda {\n    const programId = this.programId(input.programs);\n    return Pda.find(programId, [\n      Buffer.from('metadata', 'utf8'),\n      programId.toBuffer(),\n      input.mint.toBuffer(),\n      Buffer.from(getMetadataDelegateRoleSeed(input.type), 'utf8'),\n      input.updateAuthority.toBuffer(),\n      input.delegate.toBuffer(),\n    ]);\n  }\n\n  private programId(programs?: Program[]) {\n    return this.metaplex.programs().getTokenMetadata(programs).address;\n  }\n}\n\ntype MintAddressPdaInput = {\n  /** The address of the mint account. */\n  mint: PublicKey;\n\n  /** An optional set of programs that override the registered ones. */\n  programs?: Program[];\n};\n","import { PublicKey } from '@solana/web3.js';\nimport { Nft, toNft } from '../models';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n  ReadApiAsset,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  toMetadataFromReadApiAsset,\n  toMintFromReadApiAsset,\n  toNftEditionFromReadApiAsset,\n} from '@/utils/readApiConnection';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindNftByAssetIdOperation' as const;\n\n/**\n * Finds an NFT or an SFT by its mint address.\n *\n * ```ts\n * const nft = await metaplex\n *   .nfts()\n *   .findByAssetId({ assetId };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findNftByAssetIdOperation =\n  useOperation<FindNftByAssetIdOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindNftByAssetIdOperation = Operation<\n  typeof Key,\n  FindNftByAssetIdInput,\n  FindNftByAssetIdOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindNftByAssetIdInput = {\n  /** The id of an asset. */\n  assetId: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type FindNftByAssetIdOutput = Nft;\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findNftByAssetIdOperationHandler: OperationHandler<FindNftByAssetIdOperation> =\n  {\n    handle: async (\n      operation: FindNftByAssetIdOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<FindNftByAssetIdOutput> => {\n      const { assetId } = operation.input;\n\n      // Retrieve asset from RPC\n      // Massage into the NFT model\n\n      const asset = await metaplex.rpc().getAsset(assetId);\n      scope.throwIfCanceled();\n\n      const metadata = toMetadataFromReadApiAsset(asset as ReadApiAsset);\n      const mint = toMintFromReadApiAsset(asset as ReadApiAsset);\n      const nftEdition = toNftEditionFromReadApiAsset(asset as ReadApiAsset);\n\n      return toNft(metadata, mint, nftEdition);\n    },\n  };\n","import { PublicKey } from '@solana/web3.js';\nimport {\n  toMint,\n  toMintAccount,\n  toToken,\n  toTokenAccount,\n} from '../../tokenModule';\nimport {\n  parseOriginalOrPrintEditionAccount,\n  toMetadataAccount,\n} from '../accounts';\nimport {\n  JsonMetadata,\n  Nft,\n  NftWithToken,\n  Sft,\n  SftWithToken,\n  toMetadata,\n  toNft,\n  toNftEdition,\n  toNftWithToken,\n  toSft,\n  toSftWithToken,\n} from '../models';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindNftByMintOperation' as const;\n\n/**\n * Finds an NFT or an SFT by its mint address.\n *\n * ```ts\n * const nft = await metaplex\n *   .nfts()\n *   .findByMint({ mintAddress };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findNftByMintOperation = useOperation<FindNftByMintOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindNftByMintOperation = Operation<\n  typeof Key,\n  FindNftByMintInput,\n  FindNftByMintOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindNftByMintInput = {\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /**\n   * The explicit token account to fetch with the NFT or SFT.\n   *\n   * If provided, and if that address is valid, the NFT or SFT returned\n   * will be of the type `NftWithToken` or `SftWithToken` respectively.\n   *\n   * Alternatively, you may use the `tokenOwner` parameter to fetch the\n   * associated token account.\n   *\n   * @defaultValue Defaults to not fetching the token account.\n   */\n  tokenAddress?: PublicKey;\n\n  /**\n   * The associated token account to fetch with the NFT or SFT.\n   *\n   * If provided, and if that account exists, the NFT or SFT returned\n   * will be of the type `NftWithToken` or `SftWithToken` respectively.\n   *\n   * Alternatively, you may use the `tokenAddress` parameter to fetch the\n   * token account at an explicit address.\n   *\n   * @defaultValue Defaults to not fetching the associated token account.\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * Whether or not we should fetch the JSON Metadata for the NFT or SFT.\n   *\n   * @defaultValue `true`\n   */\n  loadJsonMetadata?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type FindNftByMintOutput = Nft | Sft | NftWithToken | SftWithToken;\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findNftByMintOperationHandler: OperationHandler<FindNftByMintOperation> =\n  {\n    handle: async (\n      operation: FindNftByMintOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<FindNftByMintOutput> => {\n      const { programs, commitment } = scope;\n      const {\n        mintAddress,\n        tokenAddress,\n        tokenOwner,\n        loadJsonMetadata = true,\n      } = operation.input;\n\n      const associatedTokenAddress = tokenOwner\n        ? metaplex.tokens().pdas().associatedTokenAccount({\n            mint: mintAddress,\n            owner: tokenOwner,\n            programs,\n          })\n        : undefined;\n      const nftPdas = metaplex.nfts().pdas();\n      const accountAddresses = [\n        mintAddress,\n        nftPdas.metadata({ mint: mintAddress, programs }),\n        nftPdas.masterEdition({ mint: mintAddress, programs }),\n        tokenAddress ?? associatedTokenAddress,\n      ].filter((address): address is PublicKey => !!address);\n\n      const accounts = await metaplex\n        .rpc()\n        .getMultipleAccounts(accountAddresses, commitment);\n      scope.throwIfCanceled();\n\n      const mint = toMint(toMintAccount(accounts[0]));\n      let metadata = toMetadata(toMetadataAccount(accounts[1]));\n      const editionAccount = parseOriginalOrPrintEditionAccount(accounts[2]);\n      const token = accounts[3] ? toToken(toTokenAccount(accounts[3])) : null;\n\n      if (loadJsonMetadata) {\n        try {\n          const json = await metaplex\n            .storage()\n            .downloadJson<JsonMetadata>(metadata.uri, scope);\n          metadata = { ...metadata, jsonLoaded: true, json };\n        } catch (error) {\n          metadata = { ...metadata, jsonLoaded: true, json: null };\n        }\n      }\n\n      const isNft =\n        editionAccount.exists &&\n        mint.mintAuthorityAddress &&\n        mint.mintAuthorityAddress.equals(editionAccount.publicKey);\n\n      if (isNft) {\n        const edition = toNftEdition(editionAccount);\n        return token\n          ? toNftWithToken(metadata, mint, edition, token)\n          : toNft(metadata, mint, edition);\n      }\n\n      return token\n        ? toSftWithToken(metadata, mint, token)\n        : toSft(metadata, mint);\n    },\n  };\n","import { PublicKey } from '@solana/web3.js';\nimport { toMetadataAccount } from '../accounts';\nimport { Nft, NftWithToken, Sft, SftWithToken } from '../models';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindNftByMetadataOperation' as const;\n\n/**\n * Finds an NFT or an SFT by its metadata address.\n *\n * ```ts\n * const nft = await metaplex\n *   .nfts()\n *   .findByMetadata({ metadata };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findNftByMetadataOperation =\n  useOperation<FindNftByMetadataOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindNftByMetadataOperation = Operation<\n  typeof Key,\n  FindNftByMetadataInput,\n  FindNftByMetadataOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindNftByMetadataInput = {\n  /** The address of the metadata account. */\n  metadata: PublicKey;\n\n  /**\n   * The explicit token account to fetch with the NFT or SFT.\n   *\n   * If provided, and if that address is valid, the NFT or SFT returned\n   * will be of the type `NftWithToken` or `SftWithToken` respectively.\n   *\n   * Alternatively, you may use the `tokenOwner` parameter to fetch the\n   * associated token account.\n   *\n   * @defaultValue Defaults to not fetching the token account.\n   */\n  tokenAddress?: PublicKey;\n\n  /**\n   * The associated token account to fetch with the NFT or SFT.\n   *\n   * If provided, and if that account exists, the NFT or SFT returned\n   * will be of the type `NftWithToken` or `SftWithToken` respectively.\n   *\n   * Alternatively, you may use the `tokenAddress` parameter to fetch the\n   * token account at an explicit address.\n   *\n   * @defaultValue Defaults to not fetching the associated token account.\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * Whether or not we should fetch the JSON Metadata for the NFT or SFT.\n   *\n   * @defaultValue `true`\n   */\n  loadJsonMetadata?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type FindNftByMetadataOutput = Nft | Sft | NftWithToken | SftWithToken;\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findNftByMetadataOperationHandler: OperationHandler<FindNftByMetadataOperation> =\n  {\n    handle: async (\n      operation: FindNftByMetadataOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<FindNftByMetadataOutput> => {\n      const metadata = toMetadataAccount(\n        await metaplex.rpc().getAccount(operation.input.metadata)\n      );\n      scope.throwIfCanceled();\n\n      return metaplex\n        .nfts()\n        .findByMint(\n          { ...operation.input, mintAddress: metadata.data.mint },\n          scope\n        );\n    },\n  };\n","import { PublicKey } from '@solana/web3.js';\nimport { toTokenAccount } from '../../tokenModule';\nimport { NftWithToken, SftWithToken } from '../models';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindNftByTokenOperation' as const;\n\n/**\n * Finds an NFT or an SFT by its token address.\n *\n * ```ts\n * const nft = await metaplex\n *   .nfts()\n *   .findByToken({ token };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findNftByTokenOperation =\n  useOperation<FindNftByTokenOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindNftByTokenOperation = Operation<\n  typeof Key,\n  FindNftByTokenInput,\n  FindNftByTokenOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindNftByTokenInput = {\n  /** The address of the token account. */\n  token: PublicKey;\n\n  /**\n   * Whether or not we should fetch the JSON Metadata for the NFT or SFT.\n   *\n   * @defaultValue `true`\n   */\n  loadJsonMetadata?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type FindNftByTokenOutput = NftWithToken | SftWithToken;\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findNftByTokenOperationHandler: OperationHandler<FindNftByTokenOperation> =\n  {\n    handle: async (\n      operation: FindNftByTokenOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<FindNftByTokenOutput> => {\n      const token = toTokenAccount(\n        await metaplex.rpc().getAccount(operation.input.token)\n      );\n      scope.throwIfCanceled();\n\n      const asset = await metaplex.nfts().findByMint(\n        {\n          ...operation.input,\n          mintAddress: token.data.mint,\n          tokenAddress: operation.input.token,\n        },\n        scope\n      );\n\n      return asset as FindNftByTokenOutput;\n    },\n  };\n","import { Buffer } from 'buffer';\nimport { PublicKey } from '@solana/web3.js';\nimport { Key, PROGRAM_ID } from '@metaplex-foundation/mpl-token-metadata';\nimport { Metaplex } from '@/Metaplex';\nimport { GpaBuilder, padEmptyChars } from '@/utils';\nimport { toBigNumber } from '@/types';\n\nconst MAX_NAME_LENGTH = 32;\nconst MAX_SYMBOL_LENGTH = 10;\nconst MAX_URI_LENGTH = 200;\nconst MAX_CREATOR_LEN = 32 + 1 + 1;\nconst DATA_START = 1 + 32 + 32;\nconst NAME_START = DATA_START + 4;\nconst SYMBOL_START = NAME_START + MAX_NAME_LENGTH + 4;\nconst URI_START = SYMBOL_START + MAX_SYMBOL_LENGTH + 4;\nconst CREATORS_START = URI_START + MAX_URI_LENGTH + 2 + 1 + 4;\n\nexport class TokenMetadataGpaBuilder extends GpaBuilder {\n  constructor(metaplex: Metaplex, programId?: PublicKey) {\n    super(metaplex, programId ?? PROGRAM_ID);\n  }\n\n  whereKey(key: Key) {\n    return this.where(0, toBigNumber(key, 'le'));\n  }\n}\n\nexport class MetadataV1GpaBuilder extends TokenMetadataGpaBuilder {\n  constructor(metaplex: Metaplex, programId?: PublicKey) {\n    super(metaplex, programId);\n    this.whereKey(Key.MetadataV1);\n  }\n\n  selectUpdatedAuthority() {\n    return this.slice(1, 32);\n  }\n\n  whereUpdateAuthority(updateAuthority: PublicKey) {\n    return this.where(1, updateAuthority);\n  }\n\n  selectMint() {\n    return this.slice(33, 32);\n  }\n\n  whereMint(mint: PublicKey) {\n    return this.where(33, mint);\n  }\n\n  selectName() {\n    return this.slice(NAME_START, MAX_NAME_LENGTH);\n  }\n\n  whereName(name: string) {\n    return this.where(\n      NAME_START,\n      Buffer.from(padEmptyChars(name, MAX_NAME_LENGTH))\n    );\n  }\n\n  selectSymbol() {\n    return this.slice(SYMBOL_START, MAX_SYMBOL_LENGTH);\n  }\n\n  whereSymbol(symbol: string) {\n    return this.where(\n      SYMBOL_START,\n      Buffer.from(padEmptyChars(symbol, MAX_SYMBOL_LENGTH))\n    );\n  }\n\n  selectUri() {\n    return this.slice(URI_START, MAX_URI_LENGTH);\n  }\n\n  whereUri(uri: string) {\n    return this.where(\n      URI_START,\n      Buffer.from(padEmptyChars(uri, MAX_URI_LENGTH))\n    );\n  }\n\n  selectCreator(position: number) {\n    return this.slice(\n      CREATORS_START + (position - 1) * MAX_CREATOR_LEN,\n      CREATORS_START + position * MAX_CREATOR_LEN\n    );\n  }\n\n  whereCreator(position: number, creator: PublicKey) {\n    return this.where(\n      CREATORS_START + (position - 1) * MAX_CREATOR_LEN,\n      creator\n    );\n  }\n\n  selectFirstCreator() {\n    return this.selectCreator(1);\n  }\n\n  whereFirstCreator(firstCreator: PublicKey) {\n    return this.whereCreator(1, firstCreator);\n  }\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { toMetadataAccount } from '../accounts';\nimport { MetadataV1GpaBuilder } from '../gpaBuilders';\nimport { Metadata, Nft, Sft, toMetadata } from '../models';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindNftsByCreatorOperation' as const;\n\n/**\n * Finds multiple NFTs and SFTs by their creator at a given position.\n *\n * ```ts\n * // Find all by first creator.\n * const nfts = await metaplex\n *   .nfts()\n *   .findAllByCreator({ creator };\n *\n * // Find all by second creator.\n * const nfts = await metaplex\n *   .nfts()\n *   .findAllByCreator({ creator, position: 2 };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findNftsByCreatorOperation =\n  useOperation<FindNftsByCreatorOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindNftsByCreatorOperation = Operation<\n  typeof Key,\n  FindNftsByCreatorInput,\n  FindNftsByCreatorOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindNftsByCreatorInput = {\n  /** The address of the creator. */\n  creator: PublicKey;\n\n  /**\n   * The position in which the provided creator should be located at.\n   * E.g. `1` for searching the first creator, `2` for searching the\n   * second creator, etc.\n   *\n   * @defaultValue `1`\n   */\n  position?: number;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type FindNftsByCreatorOutput = (Metadata | Nft | Sft)[];\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findNftsByCreatorOperationHandler: OperationHandler<FindNftsByCreatorOperation> =\n  {\n    handle: async (\n      operation: FindNftsByCreatorOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<FindNftsByCreatorOutput> => {\n      const { programs } = scope;\n      const { creator, position = 1 } = operation.input;\n\n      const gpaBuilder = new MetadataV1GpaBuilder(\n        metaplex,\n        metaplex.programs().getTokenMetadata(programs).address\n      );\n\n      const nfts = await gpaBuilder.whereCreator(position, creator).get();\n      scope.throwIfCanceled();\n\n      return nfts\n        .map<Metadata | null>((account) => {\n          if (account == null) {\n            return null;\n          }\n\n          try {\n            return toMetadata(toMetadataAccount(account));\n          } catch (error) {\n            return null;\n          }\n        })\n        .filter((nft): nft is Metadata => nft !== null);\n    },\n  };\n","import { PublicKey } from '@solana/web3.js';\nimport { toMetadataAccount } from '../accounts';\nimport { Metadata, Nft, Sft, toMetadata } from '../models';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { GmaBuilder } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindNftsByMintListOperation' as const;\n\n/**\n * Finds multiple NFTs and SFTs by a given list of mint addresses.\n *\n * ```ts\n * const nfts = await metaplex\n *   .nfts()\n *   .findAllByMintList({ mints: [...] };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findNftsByMintListOperation =\n  useOperation<FindNftsByMintListOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindNftsByMintListOperation = Operation<\n  typeof Key,\n  FindNftsByMintListInput,\n  FindNftsByMintListOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindNftsByMintListInput = {\n  /** The addresses of all mint accounts we want to fetch. */\n  mints: PublicKey[];\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type FindNftsByMintListOutput = (Metadata | Nft | Sft | null)[];\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findNftsByMintListOperationHandler: OperationHandler<FindNftsByMintListOperation> =\n  {\n    handle: async (\n      operation: FindNftsByMintListOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<FindNftsByMintListOutput> => {\n      const { commitment, programs } = scope;\n      const { mints } = operation.input;\n      const nftPdas = metaplex.nfts().pdas();\n      const metadataPdas = mints.map((mint) =>\n        nftPdas.metadata({ mint, programs })\n      );\n      const metadataInfos = await GmaBuilder.make(metaplex, metadataPdas, {\n        commitment,\n      }).get();\n      scope.throwIfCanceled();\n\n      return metadataInfos.map<Metadata | null>((account) => {\n        if (!account.exists) {\n          return null;\n        }\n\n        try {\n          return toMetadata(toMetadataAccount(account));\n        } catch (error) {\n          return null;\n        }\n      });\n    },\n  };\n","import { PublicKey } from '@solana/web3.js';\nimport { TokenGpaBuilder } from '../../tokenModule';\nimport { Metadata, Nft, Sft } from '../models';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindNftsByOwnerOperation' as const;\n\n/**\n * Finds multiple NFTs and SFTs by a given owner.\n *\n * ```ts\n * const nfts = await metaplex\n *   .nfts()\n *   .findAllByOwner({ owner };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findNftsByOwnerOperation =\n  useOperation<FindNftsByOwnerOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindNftsByOwnerOperation = Operation<\n  typeof Key,\n  FindNftsByOwnerInput,\n  FindNftsByOwnerOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindNftsByOwnerInput = {\n  /** The address of the owner. */\n  owner: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type FindNftsByOwnerOutput = (Metadata | Nft | Sft)[];\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findNftsByOwnerOperationHandler: OperationHandler<FindNftsByOwnerOperation> =\n  {\n    handle: async (\n      operation: FindNftsByOwnerOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<FindNftsByOwnerOutput> => {\n      const { programs } = scope;\n      const { owner } = operation.input;\n\n      const tokenProgram = metaplex.programs().getToken(programs);\n      const mints = await new TokenGpaBuilder(metaplex, tokenProgram.address)\n        .selectMint()\n        .whereOwner(owner)\n        .whereAmount(1)\n        .getDataAsPublicKeys();\n      scope.throwIfCanceled();\n\n      const nfts = await metaplex.nfts().findAllByMintList({ mints }, scope);\n      scope.throwIfCanceled();\n\n      return nfts.filter((nft): nft is Metadata | Nft | Sft => nft !== null);\n    },\n  };\n","import { PublicKey } from '@solana/web3.js';\nimport { toMetadataAccount } from '../accounts';\nimport { MetadataV1GpaBuilder } from '../gpaBuilders';\nimport { Metadata, Nft, Sft, toMetadata } from '../models';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindNftsByUpdateAuthorityOperation' as const;\n\n/**\n * Finds multiple NFTs and SFTs by a given update authority.\n *\n * ```ts\n * const nfts = await metaplex\n *   .nfts()\n *   .findAllByUpdateAuthority({ updateAuthority };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const findNftsByUpdateAuthorityOperation =\n  useOperation<FindNftsByUpdateAuthorityOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type FindNftsByUpdateAuthorityOperation = Operation<\n  typeof Key,\n  FindNftsByUpdateAuthorityInput,\n  FindNftsByUpdateAuthorityOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type FindNftsByUpdateAuthorityInput = {\n  /** The address of the update authority. */\n  updateAuthority: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type FindNftsByUpdateAuthorityOutput = (Metadata | Nft | Sft)[];\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const findNftsByUpdateAuthorityOperationHandler: OperationHandler<FindNftsByUpdateAuthorityOperation> =\n  {\n    handle: async (\n      operation: FindNftsByUpdateAuthorityOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<FindNftsByUpdateAuthorityOutput> => {\n      const { updateAuthority } = operation.input;\n\n      const gpaBuilder = new MetadataV1GpaBuilder(\n        metaplex,\n        metaplex.programs().getTokenMetadata(scope.programs).address\n      );\n\n      const nfts = await gpaBuilder.whereUpdateAuthority(updateAuthority).get();\n      scope.throwIfCanceled();\n\n      return nfts\n        .map<Metadata | null>((account) => {\n          if (account == null) {\n            return null;\n          }\n\n          try {\n            return toMetadata(toMetadataAccount(account));\n          } catch (error) {\n            return null;\n          }\n        })\n        .filter((nft): nft is Metadata => nft !== null);\n    },\n  };\n","import { PublicKey } from '@solana/web3.js';\nimport { Metadata, Nft, NftWithToken, Sft, SftWithToken } from '../models';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'LoadMetadataOperation' as const;\n\n/**\n * Transforms a `Metadata` model into a `Nft` or `Sft` model.\n *\n * ```ts\n * const nfts = await metaplex\n *   .nfts()\n *   .load({ metadata };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const loadMetadataOperation = useOperation<LoadMetadataOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type LoadMetadataOperation = Operation<\n  typeof Key,\n  LoadMetadataInput,\n  LoadMetadataOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type LoadMetadataInput = {\n  /** The address of the metadata account. */\n  metadata: Metadata;\n\n  /**\n   * The explicit token account to fetch with the NFT or SFT.\n   *\n   * If provided, and if that address is valid, the NFT or SFT returned\n   * will be of the type `NftWithToken` or `SftWithToken` respectively.\n   *\n   * Alternatively, you may use the `tokenOwner` parameter to fetch the\n   * associated token account.\n   *\n   * @defaultValue Defaults to not fetching the token account.\n   */\n  tokenAddress?: PublicKey;\n\n  /**\n   * The associated token account to fetch with the NFT or SFT.\n   *\n   * If provided, and if that account exists, the NFT or SFT returned\n   * will be of the type `NftWithToken` or `SftWithToken` respectively.\n   *\n   * Alternatively, you may use the `tokenAddress` parameter to fetch the\n   * token account at an explicit address.\n   *\n   * @defaultValue Defaults to not fetching the associated token account.\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * Whether or not we should fetch the JSON Metadata for the NFT or SFT.\n   *\n   * @defaultValue `true`\n   */\n  loadJsonMetadata?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type LoadMetadataOutput = Nft | Sft | NftWithToken | SftWithToken;\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const loadMetadataOperationHandler: OperationHandler<LoadMetadataOperation> =\n  {\n    handle: async (\n      operation: LoadMetadataOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<LoadMetadataOutput> => {\n      const { metadata, loadJsonMetadata = true } = operation.input;\n\n      let nftOrSft = await metaplex.nfts().findByMint(\n        {\n          ...operation.input,\n          mintAddress: metadata.mintAddress,\n          loadJsonMetadata: !metadata.jsonLoaded && loadJsonMetadata,\n        },\n        scope\n      );\n\n      if (!nftOrSft.jsonLoaded && metadata.jsonLoaded) {\n        nftOrSft = { ...nftOrSft, json: metadata.json, jsonLoaded: true };\n      }\n\n      return nftOrSft;\n    },\n  };\n","import cloneDeep from 'lodash.clonedeep';\nimport { isMetaplexFile, MetaplexFile } from '../../storageModule';\nimport { JsonMetadata } from '../models';\nimport { Metaplex } from '@/Metaplex';\nimport {\n  Operation,\n  OperationHandler,\n  OperationScope,\n  useOperation,\n} from '@/types';\nimport { walk } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'UploadMetadataOperation' as const;\n\n/**\n * Uploads a JSON Metadata object to the current storage provider.\n *\n * ```ts\n * const { uri } = await metaplex\n *   .nfts()\n *   .uploadMetadata({\n *     name: \"My NFT\",\n *     description: \"My description\",\n *     image: \"https://arweave.net/123\",\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const uploadMetadataOperation =\n  useOperation<UploadMetadataOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type UploadMetadataOperation = Operation<\n  typeof Key,\n  UploadMetadataInput,\n  UploadMetadataOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type UploadMetadataInput = JsonMetadata<MetaplexFile | string>;\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type UploadMetadataOutput = {\n  /** The uploaded JSON metadata. */\n  metadata: JsonMetadata;\n\n  /**\n   * The URIs of all assets that were uploaded\n   * within the provided metadata.\n   */\n  assetUris: string[];\n\n  /** The URI of the uploaded JSON metadata. */\n  uri: string;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const uploadMetadataOperationHandler: OperationHandler<UploadMetadataOperation> =\n  {\n    handle: async (\n      operation: UploadMetadataOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<UploadMetadataOutput> => {\n      const rawMetadata = operation.input;\n      const files = getAssetsFromJsonMetadata(rawMetadata);\n      const assetUris = await metaplex.storage().uploadAll(files);\n      scope.throwIfCanceled();\n\n      const metadata = replaceAssetsWithUris(rawMetadata, assetUris);\n      const uri = await metaplex.storage().uploadJson(metadata);\n\n      return { uri, metadata, assetUris };\n    },\n  };\n\nexport const getAssetsFromJsonMetadata = (\n  input: UploadMetadataInput\n): MetaplexFile[] => {\n  const files: MetaplexFile[] = [];\n\n  walk(input, (next, value) => {\n    if (isMetaplexFile(value)) {\n      files.push(value);\n    } else {\n      next(value);\n    }\n  });\n\n  return files;\n};\n\nexport const replaceAssetsWithUris = (\n  input: UploadMetadataInput,\n  replacements: string[]\n): JsonMetadata => {\n  const clone = cloneDeep(input);\n  let index = 0;\n\n  walk(clone, (next, value, key, parent) => {\n    if (isMetaplexFile(value)) {\n      if (index < replacements.length) {\n        parent[key] = replacements[index++];\n      }\n    } else {\n      next(value);\n    }\n  });\n\n  return clone as JsonMetadata;\n};\n","import { Metadata } from '@metaplex-foundation/mpl-token-metadata';\nimport { PublicKey } from '@solana/web3.js';\nimport { toMintAddress } from './helpers';\nimport { Nft, NftWithToken, Sft, SftWithToken } from './models';\nimport { NftBuildersClient } from './NftBuildersClient';\nimport { NftPdasClient } from './NftPdasClient';\nimport {\n  ApproveNftCollectionAuthorityInput,\n  approveNftCollectionAuthorityOperation,\n  ApproveNftDelegateInput,\n  approveNftDelegateOperation,\n  ApproveNftUseAuthorityInput,\n  approveNftUseAuthorityOperation,\n  CreateCompressedNftInput,\n  createCompressedNftOperation,\n  CreateNftInput,\n  createNftOperation,\n  CreateSftInput,\n  createSftOperation,\n  DeleteNftInput,\n  deleteNftOperation,\n  FindNftByMetadataInput,\n  findNftByMetadataOperation,\n  FindNftByMintInput,\n  findNftByMintOperation,\n  FindNftByTokenInput,\n  findNftByTokenOperation,\n  FindNftsByCreatorInput,\n  findNftsByCreatorOperation,\n  FindNftsByMintListInput,\n  findNftsByMintListOperation,\n  FindNftsByOwnerInput,\n  findNftsByOwnerOperation,\n  FindNftsByUpdateAuthorityInput,\n  findNftsByUpdateAuthorityOperation,\n  FreezeDelegatedNftInput,\n  freezeDelegatedNftOperation,\n  LoadMetadataInput,\n  loadMetadataOperation,\n  LockNftInput,\n  lockNftOperation,\n  MigrateToSizedCollectionNftInput,\n  migrateToSizedCollectionNftOperation,\n  MintNftInput,\n  mintNftOperation,\n  PrintNewEditionInput,\n  printNewEditionOperation,\n  RevokeNftCollectionAuthorityInput,\n  revokeNftCollectionAuthorityOperation,\n  RevokeNftDelegateInput,\n  revokeNftDelegateOperation,\n  RevokeNftUseAuthorityInput,\n  revokeNftUseAuthorityOperation,\n  ThawDelegatedNftInput,\n  thawDelegatedNftOperation,\n  TransferNftInput,\n  transferNftOperation,\n  UnlockNftInput,\n  unlockNftOperation,\n  UnverifyNftCollectionInput,\n  unverifyNftCollectionOperation,\n  UnverifyNftCreatorInput,\n  unverifyNftCreatorOperation,\n  UpdateNftInput,\n  updateNftOperation,\n  UploadMetadataInput,\n  uploadMetadataOperation,\n  UseNftInput,\n  useNftOperation,\n  VerifyNftCollectionInput,\n  verifyNftCollectionOperation,\n  VerifyNftCreatorInput,\n  verifyNftCreatorOperation,\n} from './operations';\nimport {\n  FindNftByAssetIdInput,\n  findNftByAssetIdOperation,\n} from './operations/findNftByAssetId';\nimport { OperationOptions } from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n/**\n * This is a client for the NFT module.\n *\n * It enables us to interact with the Token Metadata program in order to\n * manage NFTs and SFTs.\n *\n * You may access this client via the `nfts()` method of your `Metaplex` instance.\n *\n * ```ts\n * const nftClient = metaplex.nfts();\n * ```\n *\n * @example\n * You can upload some custom JSON metadata and use its URI to create\n * a new NFT like so. The owner and update authority of this NFT will,\n * by default, be the current identity of the metaplex instance.\n *\n * ```ts\n * const { uri } = await metaplex\n *   .nfts()\n *   .uploadMetadata({\n *     name: \"My off-chain name\",\n *     description: \"My off-chain description\",\n *     image: \"https://arweave.net/123\",\n *   };\n *\n * const { nft } = await metaplex\n *   .nfts()\n *   .create({\n *     uri,\n *     name: 'My on-chain NFT',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   };\n * ```\n *\n * @group Modules\n */\nexport class NftClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /**\n   * You may use the `builders()` client to access the\n   * underlying Transaction Builders of this module.\n   *\n   * ```ts\n   * const buildersClient = metaplex.nfts().builders();\n   * ```\n   */\n  builders() {\n    return new NftBuildersClient(this.metaplex);\n  }\n\n  /**\n   * You may use the `pdas()` client to build PDAs related to this module.\n   *\n   * ```ts\n   * const pdasClient = metaplex.nfts().pdas();\n   * ```\n   */\n  pdas() {\n    return new NftPdasClient(this.metaplex);\n  }\n\n  // -----------------\n  // Queries\n  // -----------------\n\n  /** {@inheritDoc findNftByMintOperation} */\n  findByMint(input: FindNftByMintInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(findNftByMintOperation(input), options);\n  }\n\n  /** {@inheritDoc findNftByMetadataOperation} */\n  findByMetadata(input: FindNftByMetadataInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(findNftByMetadataOperation(input), options);\n  }\n\n  /** {@inheritDoc findNftByTokenOperation} */\n  findByToken(input: FindNftByTokenInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(findNftByTokenOperation(input), options);\n  }\n\n  /** {@inheritDoc findNftsByCreatorOperation} */\n  findAllByCreator(input: FindNftsByCreatorInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(findNftsByCreatorOperation(input), options);\n  }\n\n  /** {@inheritDoc findNftsByMintListOperation} */\n  findAllByMintList(\n    input: FindNftsByMintListInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(findNftsByMintListOperation(input), options);\n  }\n\n  /** {@inheritDoc findNftsByOwnerOperation} */\n  findAllByOwner(input: FindNftsByOwnerInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(findNftsByOwnerOperation(input), options);\n  }\n\n  /** {@inheritDoc findNftsByUpdateAuthorityOperation} */\n  findAllByUpdateAuthority(\n    input: FindNftsByUpdateAuthorityInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(findNftsByUpdateAuthorityOperation(input), options);\n  }\n\n  /** {@inheritDoc findNftByAssetIdOperation} */\n  findByAssetId(input: FindNftByAssetIdInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(findNftByAssetIdOperation(input), options);\n  }\n\n  /** {@inheritDoc loadMetadataOperation} */\n  load(input: LoadMetadataInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(loadMetadataOperation(input), options);\n  }\n\n  /**\n   * Helper method that refetches a given model\n   * and returns an instance of the same type.\n   *\n   * ```ts\n   * nft = await metaplex.nfts().refresh(nft);\n   * sft = await metaplex.nfts().refresh(sft);\n   * nftWithToken = await metaplex.nfts().refresh(nftWithToken);\n   * ```\n   */\n  refresh<\n    T extends Nft | Sft | NftWithToken | SftWithToken | Metadata | PublicKey\n  >(\n    model: T,\n    input?: Omit<\n      FindNftByMintInput,\n      'mintAddress' | 'tokenAddress' | 'tokenOwner'\n    >,\n    options?: OperationOptions\n  ): Promise<T extends Metadata | PublicKey ? Nft | Sft : T> {\n    return this.findByMint(\n      {\n        mintAddress: toMintAddress(model),\n        tokenAddress: 'token' in model ? model.token.address : undefined,\n        ...input,\n      },\n      options\n    ) as Promise<T extends Metadata | PublicKey ? Nft | Sft : T>;\n  }\n\n  // -----------------\n  // Create, Update and Delete\n  // -----------------\n\n  /** {@inheritDoc createNftOperation} */\n  create(input: CreateNftInput, options?: OperationOptions) {\n    if (input?.tree)\n      return this.metaplex\n        .operations()\n        .execute(\n          createCompressedNftOperation(input as CreateCompressedNftInput),\n          options\n        );\n    return this.metaplex\n      .operations()\n      .execute(createNftOperation(input), options);\n  }\n\n  /** {@inheritDoc createSftOperation} */\n  createSft(input: CreateSftInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(createSftOperation(input), options);\n  }\n\n  /** {@inheritDoc printNewEditionOperation} */\n  printNewEdition(input: PrintNewEditionInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(printNewEditionOperation(input), options);\n  }\n\n  /** {@inheritDoc uploadMetadataOperation} */\n  uploadMetadata(input: UploadMetadataInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(uploadMetadataOperation(input), options);\n  }\n\n  /** {@inheritDoc updateNftOperation} */\n  update(input: UpdateNftInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(updateNftOperation(input), options);\n  }\n\n  /** {@inheritDoc deleteNftOperation} */\n  delete(input: DeleteNftInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(deleteNftOperation(input), options);\n  }\n\n  // -----------------\n  // Delegates\n  // -----------------\n\n  /** {@inheritDoc approveNftDelegateOperation} */\n  delegate(input: ApproveNftDelegateInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(approveNftDelegateOperation(input), options);\n  }\n\n  /** {@inheritDoc revokeNftDelegateOperation} */\n  revoke(input: RevokeNftDelegateInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(revokeNftDelegateOperation(input), options);\n  }\n\n  // -----------------\n  // Use\n  // -----------------\n\n  /** {@inheritDoc useNftOperation} */\n  use(input: UseNftInput, options?: OperationOptions) {\n    return this.metaplex.operations().execute(useNftOperation(input), options);\n  }\n\n  /** {@inheritDoc approveNftUseAuthorityOperation} */\n  approveUseAuthority(\n    input: ApproveNftUseAuthorityInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(approveNftUseAuthorityOperation(input), options);\n  }\n\n  /** {@inheritDoc revokeNftUseAuthorityOperation} */\n  revokeUseAuthority(\n    input: RevokeNftUseAuthorityInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(revokeNftUseAuthorityOperation(input), options);\n  }\n\n  // -----------------\n  // Creators\n  // -----------------\n\n  /** {@inheritDoc verifyNftCreatorOperation} */\n  verifyCreator(input: VerifyNftCreatorInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(verifyNftCreatorOperation(input), options);\n  }\n\n  /** {@inheritDoc unverifyNftCreatorOperation} */\n  unverifyCreator(input: UnverifyNftCreatorInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(unverifyNftCreatorOperation(input), options);\n  }\n\n  // -----------------\n  // Collections\n  // -----------------\n\n  /** {@inheritDoc verifyNftCollectionOperation} */\n  verifyCollection(\n    input: VerifyNftCollectionInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(verifyNftCollectionOperation(input), options);\n  }\n\n  /** {@inheritDoc unverifyNftCollectionOperation} */\n  unverifyCollection(\n    input: UnverifyNftCollectionInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(unverifyNftCollectionOperation(input), options);\n  }\n\n  /** {@inheritDoc approveNftCollectionAuthorityOperation} */\n  approveCollectionAuthority(\n    input: ApproveNftCollectionAuthorityInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(approveNftCollectionAuthorityOperation(input), options);\n  }\n\n  /** {@inheritDoc revokeNftCollectionAuthorityOperation} */\n  revokeCollectionAuthority(\n    input: RevokeNftCollectionAuthorityInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(revokeNftCollectionAuthorityOperation(input), options);\n  }\n\n  /** {@inheritDoc migrateToSizedCollectionNftOperation} */\n  migrateToSizedCollection(\n    input: MigrateToSizedCollectionNftInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(migrateToSizedCollectionNftOperation(input), options);\n  }\n\n  // -----------------\n  // Programmables\n  // -----------------\n\n  /** {@inheritDoc lockNftOperation} */\n  lock(input: LockNftInput, options?: OperationOptions) {\n    return this.metaplex.operations().execute(lockNftOperation(input), options);\n  }\n\n  /** {@inheritDoc unlockNftOperation} */\n  unlock(input: UnlockNftInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(unlockNftOperation(input), options);\n  }\n\n  // -----------------\n  // Tokens\n  // -----------------\n\n  /** {@inheritDoc mintNftOperation} */\n  mint(input: MintNftInput, options?: OperationOptions) {\n    return this.metaplex.operations().execute(mintNftOperation(input), options);\n  }\n\n  /** {@inheritDoc transferNftOperation} */\n  transfer(input: TransferNftInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(transferNftOperation(input), options);\n  }\n\n  /** {@inheritDoc freezeDelegatedNftOperation} */\n  freezeDelegatedNft(\n    input: FreezeDelegatedNftInput,\n    options?: OperationOptions\n  ) {\n    return this.metaplex\n      .operations()\n      .execute(freezeDelegatedNftOperation(input), options);\n  }\n\n  /** {@inheritDoc thawDelegatedNftOperation} */\n  thawDelegatedNft(input: ThawDelegatedNftInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(thawDelegatedNftOperation(input), options);\n  }\n}\n","import { cusper, PROGRAM_ID } from '@metaplex-foundation/mpl-token-metadata';\nimport { ProgramClient } from '../programModule';\nimport { NftClient } from './NftClient';\nimport {\n  approveNftCollectionAuthorityOperation,\n  approveNftCollectionAuthorityOperationHandler,\n  approveNftDelegateOperation,\n  approveNftDelegateOperationHandler,\n  approveNftUseAuthorityOperation,\n  approveNftUseAuthorityOperationHandler,\n  createNftOperation,\n  createNftOperationHandler,\n  createSftOperation,\n  createSftOperationHandler,\n  deleteNftOperation,\n  deleteNftOperationHandler,\n  findNftByAssetIdOperation,\n  findNftByAssetIdOperationHandler,\n  findNftByMetadataOperation,\n  transferCompressedNftOperation,\n  transferCompressedNftOperationHandler,\n  createCompressedNftOperation,\n  createCompressedNftOperationHandler,\n  findNftByMetadataOperationHandler,\n  findNftByMintOperation,\n  findNftByMintOperationHandler,\n  findNftByTokenOperation,\n  findNftByTokenOperationHandler,\n  findNftsByCreatorOperation,\n  findNftsByCreatorOperationHandler,\n  findNftsByMintListOperation,\n  findNftsByMintListOperationHandler,\n  findNftsByOwnerOperation,\n  findNftsByOwnerOperationHandler,\n  findNftsByUpdateAuthorityOperation,\n  findNftsByUpdateAuthorityOperationHandler,\n  freezeDelegatedNftOperation,\n  freezeDelegatedNftOperationHandler,\n  loadMetadataOperation,\n  loadMetadataOperationHandler,\n  lockNftOperation,\n  lockNftOperationHandler,\n  migrateToSizedCollectionNftOperation,\n  migrateToSizedCollectionNftOperationHandler,\n  mintNftOperation,\n  mintNftOperationHandler,\n  printNewEditionOperation,\n  printNewEditionOperationHandler,\n  revokeNftCollectionAuthorityOperation,\n  revokeNftCollectionAuthorityOperationHandler,\n  revokeNftDelegateOperation,\n  revokeNftDelegateOperationHandler,\n  revokeNftUseAuthorityOperation,\n  revokeNftUseAuthorityOperationHandler,\n  thawDelegatedNftOperation,\n  thawDelegatedNftOperationHandler,\n  transferNftOperation,\n  transferNftOperationHandler,\n  unlockNftOperation,\n  unlockNftOperationHandler,\n  unverifyNftCollectionOperation,\n  unverifyNftCollectionOperationHandler,\n  unverifyNftCreatorOperation,\n  unverifyNftCreatorOperationHandler,\n  updateNftOperation,\n  updateNftOperationHandler,\n  uploadMetadataOperation,\n  uploadMetadataOperationHandler,\n  useNftOperation,\n  useNftOperationHandler,\n  verifyNftCollectionOperation,\n  verifyNftCollectionOperationHandler,\n  verifyNftCreatorOperation,\n  verifyNftCreatorOperationHandler,\n} from './operations';\nimport { ErrorWithLogs, MetaplexPlugin, Program } from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n/** @group Plugins */\nexport const nftModule = (): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    // Token Metadata Program.\n    const tokenMetadataProgram = {\n      name: 'TokenMetadataProgram',\n      address: PROGRAM_ID,\n      errorResolver: (error: ErrorWithLogs) =>\n        cusper.errorFromProgramLogs(error.logs, false),\n    };\n    metaplex.programs().register(tokenMetadataProgram);\n    metaplex.programs().getTokenMetadata = function (\n      this: ProgramClient,\n      programs?: Program[]\n    ) {\n      return this.get(tokenMetadataProgram.name, programs);\n    };\n\n    // Operations.\n    const op = metaplex.operations();\n    op.register(\n      approveNftCollectionAuthorityOperation,\n      approveNftCollectionAuthorityOperationHandler\n    );\n    op.register(\n      approveNftDelegateOperation,\n      approveNftDelegateOperationHandler\n    );\n    op.register(\n      approveNftUseAuthorityOperation,\n      approveNftUseAuthorityOperationHandler\n    );\n    op.register(createNftOperation, createNftOperationHandler);\n    op.register(createSftOperation, createSftOperationHandler);\n    op.register(deleteNftOperation, deleteNftOperationHandler);\n    op.register(findNftByAssetIdOperation, findNftByAssetIdOperationHandler);\n    op.register(\n      createCompressedNftOperation,\n      createCompressedNftOperationHandler\n    );\n    op.register(\n      transferCompressedNftOperation,\n      transferCompressedNftOperationHandler\n    );\n    op.register(findNftByMetadataOperation, findNftByMetadataOperationHandler);\n    op.register(findNftByMintOperation, findNftByMintOperationHandler);\n    op.register(findNftByTokenOperation, findNftByTokenOperationHandler);\n    op.register(findNftsByCreatorOperation, findNftsByCreatorOperationHandler);\n    op.register(\n      findNftsByMintListOperation,\n      findNftsByMintListOperationHandler\n    );\n    op.register(findNftsByOwnerOperation, findNftsByOwnerOperationHandler);\n    op.register(\n      findNftsByUpdateAuthorityOperation,\n      findNftsByUpdateAuthorityOperationHandler\n    );\n    op.register(\n      freezeDelegatedNftOperation,\n      freezeDelegatedNftOperationHandler\n    );\n    op.register(loadMetadataOperation, loadMetadataOperationHandler);\n    op.register(lockNftOperation, lockNftOperationHandler);\n    op.register(\n      migrateToSizedCollectionNftOperation,\n      migrateToSizedCollectionNftOperationHandler\n    );\n    op.register(mintNftOperation, mintNftOperationHandler);\n    op.register(printNewEditionOperation, printNewEditionOperationHandler);\n    op.register(\n      revokeNftCollectionAuthorityOperation,\n      revokeNftCollectionAuthorityOperationHandler\n    );\n    op.register(revokeNftDelegateOperation, revokeNftDelegateOperationHandler);\n    op.register(\n      revokeNftUseAuthorityOperation,\n      revokeNftUseAuthorityOperationHandler\n    );\n    op.register(thawDelegatedNftOperation, thawDelegatedNftOperationHandler);\n    op.register(transferNftOperation, transferNftOperationHandler);\n    op.register(unlockNftOperation, unlockNftOperationHandler);\n    op.register(\n      unverifyNftCollectionOperation,\n      unverifyNftCollectionOperationHandler\n    );\n    op.register(\n      unverifyNftCreatorOperation,\n      unverifyNftCreatorOperationHandler\n    );\n    op.register(updateNftOperation, updateNftOperationHandler);\n    op.register(uploadMetadataOperation, uploadMetadataOperationHandler);\n    op.register(useNftOperation, useNftOperationHandler);\n    op.register(\n      verifyNftCollectionOperation,\n      verifyNftCollectionOperationHandler\n    );\n    op.register(verifyNftCreatorOperation, verifyNftCreatorOperationHandler);\n\n    metaplex.nfts = function () {\n      return new NftClient(this);\n    };\n  },\n});\n\ndeclare module '../../Metaplex' {\n  interface Metaplex {\n    nfts(): NftClient;\n  }\n}\n\ndeclare module '../programModule/ProgramClient' {\n  interface ProgramClient {\n    getTokenMetadata(programs?: Program[]): Program;\n  }\n}\n","import type { Metaplex } from '@/Metaplex';\nimport {\n  OperationConstructor,\n  Operation,\n  KeyOfOperation,\n  InputOfOperation,\n  OutputOfOperation,\n  OperationHandler,\n  OperationOptions,\n  OperationScope,\n} from '@/types';\nimport { Disposable, DisposableScope } from '@/utils';\nimport { OperationHandlerMissingError } from '@/errors';\n\n/**\n * @group Modules\n */\nexport class OperationClient {\n  /**\n   * Maps the name of an operation with its operation handler.\n   * Whilst the types on the Map are relatively loose, we ensure\n   * operations match with their handlers when registering them.\n   */\n  protected operationHandlers: Map<\n    string,\n    OperationHandler<any, any, any, any>\n  > = new Map();\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  register<\n    T extends Operation<K, I, O>,\n    K extends string = KeyOfOperation<T>,\n    I = InputOfOperation<T>,\n    O = OutputOfOperation<T>\n  >(\n    operationConstructor: OperationConstructor<T, K, I, O>,\n    operationHandler: OperationHandler<T, K, I, O>\n  ) {\n    this.operationHandlers.set(operationConstructor.key, operationHandler);\n\n    return this;\n  }\n\n  get<\n    T extends Operation<K, I, O>,\n    K extends string = KeyOfOperation<T>,\n    I = InputOfOperation<T>,\n    O = OutputOfOperation<T>\n  >(operation: T): OperationHandler<T, K, I, O> {\n    const operationHandler = this.operationHandlers.get(operation.key) as\n      | OperationHandler<T, K, I, O>\n      | undefined;\n\n    if (!operationHandler) {\n      throw new OperationHandlerMissingError(operation.key);\n    }\n\n    return operationHandler;\n  }\n\n  async execute<\n    T extends Operation<K, I, O>,\n    K extends string = KeyOfOperation<T>,\n    I = InputOfOperation<T>,\n    O = OutputOfOperation<T>\n  >(operation: T, options: OperationOptions = {}): Promise<O> {\n    const operationHandler = this.get<T, K, I, O>(operation);\n    const signal = options.signal ?? new AbortController().signal;\n\n    return new Disposable(signal).run((scope) =>\n      operationHandler.handle(\n        operation,\n        this.metaplex,\n        this.getOperationScope(options, scope)\n      )\n    );\n  }\n\n  protected getOperationScope(\n    options: OperationOptions,\n    scope: DisposableScope\n  ): OperationScope {\n    if (!!options.commitment && !options.confirmOptions) {\n      options.confirmOptions = { commitment: options.commitment };\n    }\n\n    const payer = options.payer ?? this.metaplex.rpc().getDefaultFeePayer();\n\n    return { ...options, ...scope, payer };\n  }\n}\n","import { OperationClient } from './OperationClient';\nimport type { Metaplex } from '@/Metaplex';\nimport { MetaplexPlugin } from '@/types';\n\n/** @group Plugins */\nexport const operationModule = (): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    const operationClient = new OperationClient(metaplex);\n    metaplex.operations = () => operationClient;\n  },\n});\n\ndeclare module '../../Metaplex' {\n  interface Metaplex {\n    operations(): OperationClient;\n  }\n}\n","import { PublicKey } from '@solana/web3.js';\nimport type { Metaplex } from '@/Metaplex';\nimport { ProgramNotRecognizedError } from '@/errors';\nimport { Program, Cluster } from '@/types';\n\n/**\n * @group Modules\n */\nexport class ProgramClient {\n  protected programs: Program[] = [];\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  register(program: Program): void {\n    this.programs.unshift(program);\n  }\n\n  all(overrides: Program[] = []): Program[] {\n    return [...overrides, ...this.programs];\n  }\n\n  allForCluster(cluster: Cluster, overrides: Program[] = []): Program[] {\n    return this.all(overrides).filter((program) => {\n      return program.clusterFilter?.(cluster) ?? true;\n    });\n  }\n\n  allForCurrentCluster(overrides: Program[] = []): Program[] {\n    return this.allForCluster(this.metaplex.cluster, overrides);\n  }\n\n  get<T extends Program = Program>(\n    nameOrAddress: string | PublicKey,\n    overrides: Program[] = []\n  ): T {\n    const programs = this.allForCurrentCluster(overrides);\n    const program =\n      typeof nameOrAddress === 'string'\n        ? programs.find((program) => program.name === nameOrAddress)\n        : programs.find((program) => program.address.equals(nameOrAddress));\n\n    if (!program) {\n      throw new ProgramNotRecognizedError(nameOrAddress, this.metaplex.cluster);\n    }\n\n    return program as T;\n  }\n}\n","import { ProgramClient } from './ProgramClient';\nimport type { Metaplex } from '@/Metaplex';\nimport { MetaplexPlugin } from '@/types';\n\n/** @group Plugins */\nexport const programModule = (): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    const programClient = new ProgramClient(metaplex);\n    metaplex.programs = () => programClient;\n  },\n});\n\ndeclare module '../../Metaplex' {\n  interface Metaplex {\n    programs(): ProgramClient;\n  }\n}\n","import { Buffer } from 'buffer';\nimport {\n  AccountInfo,\n  Blockhash,\n  BlockhashWithExpiryBlockHeight,\n  Commitment,\n  ConfirmOptions,\n  GetLatestBlockhashConfig,\n  GetProgramAccountsConfig,\n  PublicKey,\n  RpcResponseAndContext,\n  SendOptions,\n  SignatureResult,\n  Transaction,\n  TransactionSignature,\n} from '@solana/web3.js';\nimport {\n  FailedToConfirmTransactionError,\n  FailedToConfirmTransactionWithResponseError,\n  FailedToSendTransactionError,\n  MetaplexError,\n  ParsedProgramError,\n  RpcError,\n  UnknownProgramError,\n} from '@/errors';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  assertSol,\n  getSignerHistogram,\n  isErrorWithLogs,\n  lamports,\n  Program,\n  Signer,\n  SolAmount,\n  UnparsedAccount,\n  UnparsedMaybeAccount,\n} from '@/types';\nimport { TransactionBuilder, zipMap } from '@/utils';\n\nimport type {\n  ReadApiAsset,\n  ReadApiAssetList,\n  GetAssetProofRpcResponse,\n  GetAssetsByGroupRpcInput,\n  GetAssetsByOwnerRpcInput,\n} from '@/types/ReadApi';\nimport { ReadApiConnection } from '@/utils/readApiConnection';\n\nexport type ConfirmTransactionResponse = RpcResponseAndContext<SignatureResult>;\nexport type SendAndConfirmTransactionResponse = {\n  signature: TransactionSignature;\n  confirmResponse: ConfirmTransactionResponse;\n  blockhash: Blockhash;\n  lastValidBlockHeight: number;\n};\n\n/**\n * @group Modules\n */\nexport class RpcClient {\n  protected defaultFeePayer?: Signer;\n\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  protected async prepareTransaction(\n    transaction: Transaction | TransactionBuilder,\n    signers: Signer[]\n  ): Promise<{\n    transaction: Transaction;\n    signers: Signer[];\n    blockhashWithExpiryBlockHeight: BlockhashWithExpiryBlockHeight;\n  }> {\n    let blockhashWithExpiryBlockHeight: BlockhashWithExpiryBlockHeight;\n    if (\n      !('records' in transaction) &&\n      transaction.recentBlockhash &&\n      transaction.lastValidBlockHeight\n    ) {\n      blockhashWithExpiryBlockHeight = {\n        blockhash: transaction.recentBlockhash,\n        lastValidBlockHeight: transaction.lastValidBlockHeight,\n      };\n    } else {\n      blockhashWithExpiryBlockHeight = await this.getLatestBlockhash();\n    }\n\n    if ('records' in transaction) {\n      signers = [...transaction.getSigners(), ...signers];\n      transaction = transaction.toTransaction(blockhashWithExpiryBlockHeight);\n    }\n\n    return { transaction, signers, blockhashWithExpiryBlockHeight };\n  }\n\n  async signTransaction(\n    transaction: Transaction,\n    signers: Signer[]\n  ): Promise<Transaction> {\n    const { keypairs, identities } = getSignerHistogram(signers);\n\n    // Keypair signers.\n    if (keypairs.length > 0) {\n      transaction.partialSign(...keypairs);\n    }\n\n    // Identity signers.\n    for (let i = 0; i < identities.length; i++) {\n      transaction = await identities[i].signTransaction(transaction);\n    }\n\n    return transaction;\n  }\n\n  async sendTransaction(\n    transaction: Transaction | TransactionBuilder,\n    sendOptions: SendOptions = {},\n    signers: Signer[] = []\n  ): Promise<TransactionSignature> {\n    const prepared = await this.prepareTransaction(transaction, signers);\n    transaction = prepared.transaction;\n    signers = prepared.signers;\n\n    const defaultFeePayer = this.getDefaultFeePayer();\n    if (!transaction.feePayer && defaultFeePayer) {\n      transaction.feePayer = defaultFeePayer.publicKey;\n      signers = [defaultFeePayer, ...signers];\n    }\n\n    transaction = await this.signTransaction(transaction, signers);\n    const rawTransaction = transaction.serialize();\n\n    try {\n      return await this.metaplex.connection.sendRawTransaction(\n        rawTransaction,\n        sendOptions\n      );\n    } catch (error) {\n      throw this.parseProgramError(error, transaction);\n    }\n  }\n\n  async confirmTransaction(\n    signature: TransactionSignature,\n    blockhashWithExpiryBlockHeight: BlockhashWithExpiryBlockHeight,\n    commitment?: Commitment\n  ): Promise<ConfirmTransactionResponse> {\n    let rpcResponse: ConfirmTransactionResponse;\n    try {\n      rpcResponse = await this.metaplex.connection.confirmTransaction(\n        { signature, ...blockhashWithExpiryBlockHeight },\n        commitment\n      );\n    } catch (error) {\n      throw new FailedToConfirmTransactionError(error as Error);\n    }\n\n    if (rpcResponse.value.err) {\n      throw new FailedToConfirmTransactionWithResponseError(rpcResponse);\n    }\n\n    return rpcResponse;\n  }\n\n  async sendAndConfirmTransaction(\n    transaction: Transaction | TransactionBuilder,\n    confirmOptions?: ConfirmOptions,\n    signers: Signer[] = []\n  ): Promise<SendAndConfirmTransactionResponse> {\n    const prepared = await this.prepareTransaction(transaction, signers);\n    const { blockhashWithExpiryBlockHeight } = prepared;\n    transaction = prepared.transaction;\n    signers = prepared.signers;\n\n    const signature = await this.sendTransaction(\n      transaction,\n      confirmOptions,\n      signers\n    );\n\n    const confirmResponse = await this.confirmTransaction(\n      signature,\n      blockhashWithExpiryBlockHeight,\n      confirmOptions?.commitment\n    );\n\n    return { signature, confirmResponse, ...blockhashWithExpiryBlockHeight };\n  }\n\n  async getAccount(publicKey: PublicKey, commitment?: Commitment) {\n    const accountInfo = await this.metaplex.connection.getAccountInfo(\n      publicKey,\n      commitment\n    );\n\n    return this.getUnparsedMaybeAccount(publicKey, accountInfo);\n  }\n\n  async accountExists(publicKey: PublicKey, commitment?: Commitment) {\n    const balance = await this.metaplex.connection.getBalance(\n      publicKey,\n      commitment\n    );\n\n    return balance > 0;\n  }\n\n  async getMultipleAccounts(publicKeys: PublicKey[], commitment?: Commitment) {\n    const accountInfos = await this.metaplex.connection.getMultipleAccountsInfo(\n      publicKeys,\n      commitment\n    );\n\n    return zipMap(publicKeys, accountInfos, (publicKey, accountInfo) => {\n      return this.getUnparsedMaybeAccount(publicKey, accountInfo);\n    });\n  }\n\n  async getProgramAccounts(\n    programId: PublicKey,\n    configOrCommitment?: GetProgramAccountsConfig | Commitment\n  ): Promise<UnparsedAccount[]> {\n    const accounts = await this.metaplex.connection.getProgramAccounts(\n      programId,\n      configOrCommitment\n    );\n\n    return accounts.map(({ pubkey, account }) => ({\n      ...account,\n      publicKey: pubkey,\n      lamports: lamports(account.lamports),\n    }));\n  }\n\n  async airdrop(\n    publicKey: PublicKey,\n    amount: SolAmount,\n    commitment?: Commitment\n  ): Promise<SendAndConfirmTransactionResponse> {\n    assertSol(amount);\n\n    const signature = await this.metaplex.connection.requestAirdrop(\n      publicKey,\n      amount.basisPoints.toNumber()\n    );\n\n    const blockhashWithExpiryBlockHeight = await this.getLatestBlockhash();\n    const confirmResponse = await this.confirmTransaction(\n      signature,\n      blockhashWithExpiryBlockHeight,\n      commitment\n    );\n\n    return { signature, confirmResponse, ...blockhashWithExpiryBlockHeight };\n  }\n\n  async getBalance(\n    publicKey: PublicKey,\n    commitment?: Commitment\n  ): Promise<SolAmount> {\n    const balance = await this.metaplex.connection.getBalance(\n      publicKey,\n      commitment\n    );\n\n    return lamports(balance);\n  }\n\n  async getRent(bytes: number, commitment?: Commitment): Promise<SolAmount> {\n    const rent =\n      await this.metaplex.connection.getMinimumBalanceForRentExemption(\n        bytes,\n        commitment\n      );\n\n    return lamports(rent);\n  }\n\n  async getLatestBlockhash(\n    commitmentOrConfig: Commitment | GetLatestBlockhashConfig = 'finalized'\n  ): Promise<BlockhashWithExpiryBlockHeight> {\n    return this.metaplex.connection.getLatestBlockhash(commitmentOrConfig);\n  }\n\n  getSolanaExporerUrl(signature: string): string {\n    let clusterParam = '';\n    switch (this.metaplex.cluster) {\n      case 'devnet':\n        clusterParam = '?cluster=devnet';\n        break;\n      case 'testnet':\n        clusterParam = '?cluster=testnet';\n        break;\n      case 'localnet':\n      case 'custom':\n        const url = encodeURIComponent(this.metaplex.connection.rpcEndpoint);\n        clusterParam = `?cluster=custom&customUrl=${url}`;\n        break;\n    }\n\n    return `https://explorer.solana.com/tx/${signature}${clusterParam}`;\n  }\n\n  setDefaultFeePayer(payer: Signer) {\n    this.defaultFeePayer = payer;\n\n    return this;\n  }\n\n  getDefaultFeePayer(): Signer {\n    return this.defaultFeePayer\n      ? this.defaultFeePayer\n      : this.metaplex.identity();\n  }\n\n  protected getUnparsedMaybeAccount(\n    publicKey: PublicKey,\n    accountInfo: AccountInfo<Buffer> | null\n  ): UnparsedMaybeAccount {\n    if (!accountInfo) {\n      return { publicKey, exists: false };\n    }\n\n    return {\n      ...accountInfo,\n      publicKey,\n      exists: true,\n      lamports: lamports(accountInfo.lamports),\n    };\n  }\n\n  async getAsset(assetId: PublicKey): Promise<ReadApiAsset | MetaplexError> {\n    if (this.metaplex.connection instanceof ReadApiConnection) {\n      return await this.metaplex.connection.getAsset(assetId);\n    }\n\n    return new RpcError(\n      'Method not supported! Use a ReadApiConnection instead'\n    );\n  }\n\n  async getAssetProof(\n    assetId: PublicKey\n  ): Promise<GetAssetProofRpcResponse | MetaplexError> {\n    if (this.metaplex.connection instanceof ReadApiConnection) {\n      return await this.metaplex.connection.getAssetProof(assetId);\n    }\n\n    return new RpcError(\n      'Method not supported! Use a ReadApiConnection instead'\n    );\n  }\n\n  async getAssetsByGroup({\n    groupKey,\n    groupValue,\n    page,\n    limit,\n    sortBy,\n    before,\n    after,\n  }: GetAssetsByGroupRpcInput): Promise<ReadApiAssetList | MetaplexError> {\n    if (this.metaplex.connection instanceof ReadApiConnection) {\n      return await this.metaplex.connection.getAssetsByGroup({\n        groupKey,\n        groupValue,\n        page,\n        limit,\n        sortBy,\n        before,\n        after,\n      });\n    }\n\n    return new RpcError(\n      'Method not supported! Use a ReadApiConnection instead'\n    );\n  }\n\n  async getAssetsByOwner({\n    ownerAddress,\n    page,\n    limit,\n    sortBy,\n    before,\n    after,\n  }: GetAssetsByOwnerRpcInput): Promise<ReadApiAssetList | MetaplexError> {\n    if (this.metaplex.connection instanceof ReadApiConnection) {\n      return await this.metaplex.connection.getAssetsByOwner({\n        ownerAddress,\n        page,\n        limit,\n        sortBy,\n        before,\n        after,\n      });\n    }\n\n    return new RpcError(\n      'Method not supported! Use a ReadApiConnection instead'\n    );\n  }\n\n  protected parseProgramError(\n    error: unknown,\n    transaction: Transaction\n  ): MetaplexError {\n    // Ensure the error as logs.\n    if (!isErrorWithLogs(error)) {\n      return new FailedToSendTransactionError(error as Error);\n    }\n\n    // Parse the instruction number.\n    const regex = /Error processing Instruction (\\d+):/;\n    const instruction: string | null = error.message.match(regex)?.[1] ?? null;\n\n    // Ensure there is an instruction number given to find the program.\n    if (!instruction) {\n      return new FailedToSendTransactionError(error);\n    }\n\n    // Get the program ID from the instruction in the transaction.\n    const instructionNumber: number = parseInt(instruction, 10);\n    const programId: PublicKey | null =\n      transaction.instructions?.[instructionNumber]?.programId ?? null;\n\n    // Ensure we were able to find a program ID for the instruction.\n    if (!programId) {\n      return new FailedToSendTransactionError(error);\n    }\n\n    // Find a registered program if any.\n    let program: Program;\n    try {\n      program = this.metaplex.programs().get(programId);\n    } catch (_programNotFoundError) {\n      return new FailedToSendTransactionError(error);\n    }\n\n    // Ensure an error resolver exists on the program.\n    if (!program.errorResolver) {\n      return new UnknownProgramError(program, error);\n    }\n\n    // Finally, resolve the error.\n    const resolvedError = program.errorResolver(error);\n\n    return resolvedError\n      ? new ParsedProgramError(program, resolvedError, error.logs)\n      : new UnknownProgramError(program, error);\n  }\n}\n","import { RpcClient } from './RpcClient';\nimport type { Metaplex } from '@/Metaplex';\nimport { MetaplexPlugin } from '@/types';\n\n/** @group Plugins */\nexport const rpcModule = (): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    const rpcClient = new RpcClient(metaplex);\n    metaplex.rpc = () => rpcClient;\n  },\n});\n\ndeclare module '../../Metaplex' {\n  interface Metaplex {\n    rpc(): RpcClient;\n  }\n}\n","import { Buffer } from 'buffer';\nimport { getContentType, getExtension, randomStr } from '@/utils';\nimport { InvalidJsonVariableError } from '@/errors';\n\nexport type MetaplexFile = {\n  readonly buffer: Buffer;\n  readonly fileName: string;\n  readonly displayName: string;\n  readonly uniqueName: string;\n  readonly contentType: string | null;\n  readonly extension: string | null;\n  readonly tags: MetaplexFileTag[];\n};\n\nexport type MetaplexFileContent = string | Buffer | Uint8Array | ArrayBuffer;\n\nexport type MetaplexFileTag = { name: string; value: string };\n\nexport type MetaplexFileOptions = {\n  displayName?: string;\n  uniqueName?: string;\n  contentType?: string;\n  extension?: string;\n  tags?: { name: string; value: string }[];\n};\n\nexport const toMetaplexFile = (\n  content: MetaplexFileContent,\n  fileName: string,\n  options: MetaplexFileOptions = {}\n): MetaplexFile => ({\n  buffer: parseMetaplexFileContent(content),\n  fileName,\n  displayName: options.displayName ?? fileName,\n  uniqueName: options.uniqueName ?? randomStr(),\n  contentType: options.contentType ?? getContentType(fileName),\n  extension: options.extension ?? getExtension(fileName),\n  tags: options.tags ?? [],\n});\n\nexport const toMetaplexFileFromBrowser = async (\n  file: File,\n  options: MetaplexFileOptions = {}\n): Promise<MetaplexFile> => {\n  const buffer = await file.arrayBuffer();\n\n  return toMetaplexFile(buffer, file.name, options);\n};\n\nexport const toMetaplexFileFromJson = <T extends object = object>(\n  json: T,\n  fileName = 'inline.json',\n  options: MetaplexFileOptions = {}\n): MetaplexFile => {\n  let jsonString;\n\n  try {\n    jsonString = JSON.stringify(json);\n  } catch (error) {\n    throw new InvalidJsonVariableError(error as Error);\n  }\n\n  return toMetaplexFile(jsonString, fileName, options);\n};\n\nexport const parseMetaplexFileContent = (\n  content: MetaplexFileContent\n): Buffer => {\n  if (content instanceof ArrayBuffer) {\n    return Buffer.from(new Uint8Array(content));\n  }\n\n  return Buffer.from(content);\n};\n\nexport const getBytesFromMetaplexFiles = (...files: MetaplexFile[]): number =>\n  files.reduce((acc, file) => acc + file.buffer.byteLength, 0);\n\nexport const getBrowserFileFromMetaplexFile = (file: MetaplexFile): File =>\n  new File([file.buffer as BlobPart], file.fileName);\n\nexport const isMetaplexFile = (\n  metaplexFile: any\n): metaplexFile is MetaplexFile => {\n  return (\n    metaplexFile != null &&\n    typeof metaplexFile === 'object' &&\n    'buffer' in metaplexFile &&\n    'fileName' in metaplexFile &&\n    'displayName' in metaplexFile &&\n    'uniqueName' in metaplexFile &&\n    'contentType' in metaplexFile &&\n    'extension' in metaplexFile &&\n    'tags' in metaplexFile\n  );\n};\n","import fetch, { RequestInit } from 'node-fetch';\nimport {\n  getBytesFromMetaplexFiles,\n  MetaplexFile,\n  toMetaplexFile,\n  toMetaplexFileFromJson,\n} from './MetaplexFile';\nimport { StorageDownloadOptions, StorageDriver } from './StorageDriver';\nimport { Amount, HasDriver } from '@/types';\nimport { DriverNotProvidedError, InvalidJsonStringError } from '@/errors';\n\n/**\n * @group Modules\n */\nexport class StorageClient implements HasDriver<StorageDriver> {\n  private _driver: StorageDriver | null = null;\n\n  driver(): StorageDriver {\n    if (!this._driver) {\n      throw new DriverNotProvidedError('StorageDriver');\n    }\n\n    return this._driver;\n  }\n\n  setDriver(newDriver: StorageDriver): void {\n    this._driver = newDriver;\n  }\n\n  getUploadPriceForBytes(bytes: number): Promise<Amount> {\n    return this.driver().getUploadPrice(bytes);\n  }\n\n  getUploadPriceForFile(file: MetaplexFile): Promise<Amount> {\n    return this.getUploadPriceForFiles([file]);\n  }\n\n  getUploadPriceForFiles(files: MetaplexFile[]): Promise<Amount> {\n    const driver = this.driver();\n\n    return driver.getUploadPriceForFiles\n      ? driver.getUploadPriceForFiles(files)\n      : this.getUploadPriceForBytes(getBytesFromMetaplexFiles(...files));\n  }\n\n  upload(file: MetaplexFile): Promise<string> {\n    return this.driver().upload(file);\n  }\n\n  uploadAll(files: MetaplexFile[]): Promise<string[]> {\n    const driver = this.driver();\n\n    return driver.uploadAll\n      ? driver.uploadAll(files)\n      : Promise.all(files.map((file) => this.driver().upload(file)));\n  }\n\n  uploadJson<T extends object = object>(json: T): Promise<string> {\n    return this.upload(toMetaplexFileFromJson<T>(json));\n  }\n\n  async download(\n    uri: string,\n    options?: StorageDownloadOptions\n  ): Promise<MetaplexFile> {\n    const driver = this.driver();\n\n    if (driver.download) {\n      return driver.download(uri, options);\n    }\n\n    const response = await fetch(uri, options as RequestInit);\n    const buffer = await response.arrayBuffer();\n\n    return toMetaplexFile(buffer, uri);\n  }\n\n  async downloadJson<T extends object = object>(\n    uri: string,\n    options?: StorageDownloadOptions\n  ): Promise<T> {\n    const file = await this.download(uri, options);\n\n    try {\n      return JSON.parse(file.buffer.toString());\n    } catch (error) {\n      throw new InvalidJsonStringError(error as Error);\n    }\n  }\n}\n","import { StorageClient } from './StorageClient';\nimport type { Metaplex } from '@/Metaplex';\nimport { MetaplexPlugin } from '@/types';\n\n/** @group Plugins */\nexport const storageModule = (): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    const storageClient = new StorageClient();\n    metaplex.storage = () => storageClient;\n  },\n});\n\ndeclare module '../../Metaplex' {\n  interface Metaplex {\n    storage(): StorageClient;\n  }\n}\n","import { Keypair, PublicKey, SystemProgram } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  assertSol,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SolAmount,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateAccountOperation' as const;\n\n/**\n * Creates a new uninitialized Solana account.\n *\n * ```ts\n * const { newAccount } = await metaplex\n *   .system()\n *   .createAccount({ space: 100 }); // 100 bytes\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createAccountOperation = useOperation<CreateAccountOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateAccountOperation = Operation<\n  typeof Key,\n  CreateAccountInput,\n  CreateAccountOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateAccountInput = {\n  /** The space in bytes of the account to create. */\n  space: number;\n\n  /**\n   * The initial balance of the account.\n   *\n   * @defaultValue By default, this will be the minumum amount of lamports\n   * required for the account to be rent-exempt.\n   * i.e. it will be equal to `await metaplex.rpc().getRent(space)`.\n   */\n  lamports?: SolAmount;\n\n  /**\n   * The new account as a Signer since it will be mutated on-chain.\n   *\n   * @defaultValue Defaults to a new generated Keypair, i.e. `Keypair.generate()`\n   */\n  newAccount?: Signer;\n\n  /**\n   * The address of the program that should own the new account.\n   *\n   * @defaultValue Defaults to the System Program.\n   */\n  program?: PublicKey;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateAccountOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The new account created as a Signer. */\n  newAccount: Signer;\n\n  /** The lamports used to initialize the account's balance. */\n  lamports: SolAmount;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createAccountOperationHandler: OperationHandler<CreateAccountOperation> =\n  {\n    async handle(\n      operation: CreateAccountOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<CreateAccountOutput> {\n      const builder = await createAccountBuilder(\n        metaplex,\n        operation.input,\n        scope\n      );\n      scope.throwIfCanceled();\n      return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateAccountBuilderParams = Omit<\n  CreateAccountInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that creates the account. */\n  instructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateAccountBuilderContext = Omit<CreateAccountOutput, 'response'>;\n\n/**\n * Creates a new uninitialized Solana account.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .system()\n *   .builders()\n *   .createAccount({ space: 100 }); // 100 bytes\n * ```\n *\n * Note that accessing this transaction builder is asynchronous\n * because we may need to contact the cluster to get the\n * rent-exemption for the provided space.\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createAccountBuilder = async (\n  metaplex: Metaplex,\n  params: CreateAccountBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateAccountBuilderContext>> => {\n  const { payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    space,\n    newAccount = Keypair.generate(),\n    program = SystemProgram.programId,\n  } = params;\n\n  const lamports = params.lamports ?? (await metaplex.rpc().getRent(space));\n  assertSol(lamports);\n\n  return TransactionBuilder.make<CreateAccountBuilderContext>()\n    .setFeePayer(payer)\n    .setContext({\n      newAccount,\n      lamports,\n    })\n    .add({\n      instruction: SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: newAccount.publicKey,\n        space,\n        lamports: lamports.basisPoints.toNumber(),\n        programId: program,\n      }),\n      signers: [payer, newAccount],\n      key: params.instructionKey ?? 'createAccount',\n    });\n};\n","import { PublicKey, SystemProgram } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport type { Metaplex } from '@/Metaplex';\nimport {\n  assertSol,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SolAmount,\n  useOperation,\n} from '@/types';\nimport { TransactionBuilder, TransactionBuilderOptions } from '@/utils';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'TransferSolOperation' as const;\n\n/**\n * Transfers some SOL from one account to another.\n *\n * ```ts\n * await metaplex\n *   .system()\n *   .transferSol({\n *     to: new PublicKey(\"...\"),\n *     amount: sol(1.5),\n *   };\n * ````\n *\n * @group Operations\n * @category Constructors\n */\nexport const transferSolOperation = useOperation<TransferSolOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type TransferSolOperation = Operation<\n  typeof Key,\n  TransferSolInput,\n  TransferSolOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type TransferSolInput = {\n  /**\n   * The account that sends the SOLs as a Signer.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  from?: Signer;\n\n  /** The address of the account that receives the SOLs. */\n  to: PublicKey;\n\n  /** The amount of SOLs to send. */\n  amount: SolAmount;\n\n  /**\n   * Base public key to use to derive the funding account address.\n   *\n   * @defaultValue Defaults to not being used.\n   */\n  basePubkey?: PublicKey;\n\n  /**\n   * Seed to use to derive the funding account address.\n   *\n   * @defaultValue Defaults to not being used.\n   */\n  seed?: string;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type TransferSolOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const transferSolOperationHandler: OperationHandler<TransferSolOperation> =\n  {\n    async handle(\n      operation: TransferSolOperation,\n      metaplex: Metaplex,\n      scope: OperationScope\n    ): Promise<TransferSolOutput> {\n      const builder = transferSolBuilder(metaplex, operation.input, scope);\n      return builder.sendAndConfirm(metaplex, scope.confirmOptions);\n    },\n  };\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type TransferSolBuilderParams = Omit<\n  TransferSolInput,\n  'confirmOptions'\n> & {\n  /** A key to distinguish the instruction that transfers some SOL. */\n  instructionKey?: string;\n};\n\n/**\n * Transfers some SOL from one account to another.\n *\n * ```ts\n * const transactionBuilder = metaplex\n *   .system()\n *   .builders()\n *   .transferSol({\n *     to: new PublicKey(\"...\"),\n *     amount: sol(1.5),\n *   });\n * ````\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const transferSolBuilder = (\n  metaplex: Metaplex,\n  params: TransferSolBuilderParams,\n  options: TransactionBuilderOptions = {}\n): TransactionBuilder => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const { from = metaplex.identity(), to, amount, basePubkey, seed } = params;\n\n  assertSol(amount);\n\n  return TransactionBuilder.make()\n    .setFeePayer(payer)\n    .add({\n      instruction: SystemProgram.transfer({\n        fromPubkey: from.publicKey,\n        toPubkey: to,\n        lamports: amount.basisPoints.toNumber(),\n        ...(basePubkey ? { basePubkey, seed } : {}),\n        programId: metaplex.programs().getSystem(programs).address,\n      }),\n      signers: [from],\n      key: params.instructionKey ?? 'transferSol',\n    });\n};\n","import {\n  createAccountBuilder,\n  CreateAccountBuilderParams,\n  transferSolBuilder,\n  TransferSolBuilderParams,\n} from './operations';\nimport type { Metaplex } from '@/Metaplex';\nimport { TransactionBuilderOptions } from '@/utils';\n\n/**\n * This client allows you to access the underlying Transaction Builders\n * for the write operations of the System module.\n *\n * @see {@link SystemClient}\n * @group Module Builders\n * */\nexport class SystemBuildersClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /** {@inheritDoc createAccountBuilder} */\n  createAccount(\n    input: CreateAccountBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return createAccountBuilder(this.metaplex, input, options);\n  }\n\n  /** {@inheritDoc transferSolBuilder} */\n  transferSol(\n    input: TransferSolBuilderParams,\n    options?: TransactionBuilderOptions\n  ) {\n    return transferSolBuilder(this.metaplex, input, options);\n  }\n}\n","import {\n  CreateAccountInput,\n  createAccountOperation,\n  TransferSolInput,\n  transferSolOperation,\n} from './operations';\nimport { SystemBuildersClient } from './SystemBuildersClient';\nimport type { Metaplex } from '@/Metaplex';\nimport { OperationOptions } from '@/types';\n\n/**\n * This is a client for the System module.\n *\n * It enables us to interact with the System program in order to\n * create uninitialized accounts and transfer SOL.\n *\n * You may access this client via the `system()` method of your `Metaplex` instance.\n *\n * ```ts\n * const systemClient = metaplex.system();\n * ```\n *\n * @example\n * You can create a new uninitialized account with a given space in bytes\n * using the code below.\n *\n * ```ts\n * const { newAccount } = await metaplex.system().createAccount({ space: 42 });\n * ```\n *\n * @group Modules\n */\nexport class SystemClient {\n  constructor(protected readonly metaplex: Metaplex) {}\n\n  /**\n   * You may use the `builders()` client to access the\n   * underlying Transaction Builders of this module.\n   *\n   * ```ts\n   * const buildersClient = metaplex.system().builders();\n   * ```\n   */\n  builders() {\n    return new SystemBuildersClient(this.metaplex);\n  }\n\n  /** {@inheritDoc createAccountOperation} */\n  createAccount(input: CreateAccountInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(createAccountOperation(input), options);\n  }\n\n  /** {@inheritDoc transferSolOperation} */\n  transferSol(input: TransferSolInput, options?: OperationOptions) {\n    return this.metaplex\n      .operations()\n      .execute(transferSolOperation(input), options);\n  }\n}\n","import { SystemProgram } from '@solana/web3.js';\nimport { ProgramClient } from '../programModule';\nimport {\n  createAccountOperation,\n  createAccountOperationHandler,\n  transferSolOperation,\n  transferSolOperationHandler,\n} from './operations';\nimport { SystemClient } from './SystemClient';\nimport type { MetaplexPlugin, Program } from '@/types';\nimport type { Metaplex } from '@/Metaplex';\n\n/**\n * @group Plugins\n */\n/** @group Plugins */\nexport const systemModule = (): MetaplexPlugin => ({\n  install(metaplex: Metaplex) {\n    // Program.\n    const systemProgram = {\n      name: 'SystemProgram',\n      address: SystemProgram.programId,\n    };\n    metaplex.programs().register(systemProgram);\n    metaplex.programs().getSystem = function (\n      this: ProgramClient,\n      programs?: Program[]\n    ) {\n      return this.get(systemProgram.name, programs);\n    };\n\n    // Operations.\n    const op = metaplex.operations();\n    op.register(createAccountOperation, createAccountOperationHandler);\n    op.register(transferSolOperation, transferSolOperationHandler);\n\n    metaplex.system = function () {\n      return new SystemClient(this);\n    };\n  },\n});\n\ndeclare module '../../Metaplex' {\n  interface Metaplex {\n    system(): SystemClient;\n  }\n}\n\ndeclare module '../programModule/ProgramClient' {\n  interface ProgramClient {\n    getSystem(programs?: Program[]): Program;\n  }\n}\n"],"names":["GuestIdentityDriver","constructor","publicKey","this","PublicKey","default","signMessage","OperationUnauthorizedForGuestsError","signTransaction","signAllTransactions","guestIdentity","install","metaplex","identity","setDriver","IdentityClient","_defineProperty","driver","_driver","DriverNotProvidedError","newDriver","secretKey","message","transaction","transactions","verifyMessage","signature","ed25519","verify","toBytes","equals","that","isSigner","hasSecretKey","identityModule","identityClient","KeypairIdentityDriver","keypair","sign","slice","partialSign","Promise","all","map","HEADER_SIZE","MINIMUM_SIZE","IrysStorageDriver","options","_metaplex","_options","providerUrl","connection","rpcEndpoint","getUploadPrice","bytes","irys","price","getPrice","bigNumberToAmount","multipliedBy","priceMultiplier","getUploadPriceForFiles","files","reduce","sum","file","Math","max","buffer","byteLength","upload","uri","uploadAll","amount","getBytesFromMetaplexFiles","fund","promises","async","irysTx","createTransaction","tags","getMetaplexFileTagsWithContentType","status","data","uploader","uploadTransaction","AssetUploadFailedError","id","getBalance","balance","getLoadedBalance","skipBalanceCheck","toFund","amountToBigNumber","isGreaterThan","minus","BigNumber","isLessThanOrEqualTo","withdrawAll","minimumBalance","isLessThan","balanceToWithdraw","withdraw","withdrawBalance","e","IrysWithdrawError","Error","toString","_irys","initIrys","currency","address","timeout","isNode","window","process","hasOwnProperty","isKeypairSigner","initNodeirys","identitySigner","isIdentitySigner","Keypair","fromSecretKey","initWebirys","utils","getBundlerAddress","error","FailedToConnectToIrysAddressError","bPackage","_removeDoubleDefault","url","token","key","config","wallet","sendTransaction","signers","sendOptions","rpc","WebIrys","provider","ready","FailedToInitializeIrysError","bigNumber","lamports","toBigNumber","decimalPlaces","basisPoints","contentType","name","value","irysStorage","storage","isNft","model","assertNft","assert","toNft","metadata","mint","edition","toSft","isNftWithToken","assertNftWithToken","assertNftOrSftWithToken","isSftWithToken","toNftWithToken","toSftWithToken","isSft","assertSft","mintAddress","shared","symbol","metadataAddress","supply","sft","delegateAmount","toMintAddress","toPublicKey","Key","createCompressedNftOperation","useOperation","createCompressedNftOperationHandler","handle","operation","scope","builder","createCompressedNftBuilder","input","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","txInfo","getTransaction","response","maxSupportedTransactionVersion","relevantIndex","compiledInstructions","findIndex","instruction","staticAccountKeys","programIdIndex","toBase58","relevantInnerIxs","meta","innerInstructions","instructions","filter","length","assetIndex","i","changeLogEvent","deserializeChangeLogEventV1","Buffer","from","base58","index","__","assetId","getLeafAssetId","tree","BN","nft","nfts","findByAssetId","tokenAddress","masterEditionAddress","params","payer","getDefaultFeePayer","updateAuthority","creatorsInput","creators","authority","share","creator","verified","TransactionBuilder","make","setFeePayer","when","collection","collectionAuthority","collectionMetadataAddress","findProgramAddressSync","PROGRAM_ID","toBuffer","collectionMasterEditionAccount","treeAuthority","PROGRAM_ID$1","bubblegumPDA","add","createMintToCollectionV1Instruction","merkleTree","treeDelegate","leafOwner","leafDelegate","collectionMetadata","collectionMint","editionAccount","collectionAuthorityRecordPda","bubblegumSigner","compressionProgram","SPL_ACCOUNT_COMPRESSION_PROGRAM_ID","logWrapper","SPL_NOOP_PROGRAM_ID","tokenMetadataProgram","metadataArgs","isMutable","uses","tokenStandard","TokenStandard","NonFungible","primarySaleHappened","editionNonce","tokenProgramVersion","TokenProgramVersion","Original","createNftOperation","createNftOperationHandler","useNewMint","generate","useExistingMint","tokenOwner","tokenSigner","tokens","pdas","associatedTokenAccount","owner","programs","tokenAccount","getAccount","tokenExists","exists","createNftBuilder","findByMint","mintAuthority","mintTokens","sftBuilder","builders","createSft","tokenAmount","undefined","decimals","getContext","masterEdition","setContext","toMetadata","account","json","Pda","find","updateAuthorityAddress","jsonLoaded","removeEmptyChars","sellerFeeBasisPoints","collectionDetails","version","__kind","size","remaining","total","programmableConfig","isNonFungible","nftOrSft","NonFungibleEdition","ProgrammableNonFungible","isProgrammable","createSftOperation","createSftOperationHandler","associatedTokenAddress","createSftBuilder","FungibleAsset","systemProgram","getSystem","tokenProgram","getToken","getTokenMetadata","metadataPda","masterEditionPda","printSupply","maxSupply","fields","createInstruction","createCreateInstruction","sysvarInstructions","SYSVAR_INSTRUCTIONS_PUBKEY","splTokenProgram","createArgs","assetData","isCollection","ruleSet","createSigners","push","keys","createNonAtaInstruction","createToken","createAccountInstructionKey","createTokenAccountInstructionKey","initializeTokenInstructionKey","mintInstruction","toOwner","toToken","verifyAdditionalCreatorInstructions","verifyCreator","createInstructionKey","verifyCollection","collectionMintAddress","isDelegated","collectionAuthorityIsDelegated","isSizedCollection","collectionIsSized","getAccountParsingFunction","Metadata","toMetadataAccount","getAccountParsingAndAssertingFunction","originalOrPrintEditionAccountParser","deserialize","offset","MasterEditionV1","MasterEditionV2","Edition","fromArgs","NotYetImplementedError","parseOriginalOrPrintEditionAccount","isOriginalEditionAccount","originalEditionAccountParser","toOriginalEditionAccount","toNftEdition","toNftOriginalEdition","toNftPrintEdition","isOriginal","toOptionBigNumber","parent","number","printNewEditionOperation","printNewEditionOperationHandler","originalEditionAccount","originalMint","originalEdition","printNewEditionBuilder","originalSupply","mintSigner","newMint","newUpdateAuthority","newOwner","newTokenAccount","printNewEditionInstructionKey","originalMetadataAddress","originalEditionAddress","addn","originalEditionMarkPda","editionMarker","newMintAuthority","newMetadataAddress","newEditionAddress","sharedAccounts","newMetadata","newEdition","editionMarkPda","newMetadataUpdateAuthority","tokenWithMintBuilder","createTokenWithMint","initialSupply","freezeAuthority","createMintAccountInstructionKey","initializeMintInstructionKey","createAssociatedTokenAccountInstructionKey","mintTokensInstructionKey","originalTokenAccountOwner","originalTokenAccount","editionAddress","updatedSupply","createMintNewEditionFromMasterEditionViaTokenInstruction","tokenAccountOwner","mintNewEditionFromMasterEditionViaTokenArgs","parseTokenMetadataDelegateInput","isTokenDelegate","delegate","approver","delegateRecord","metadataDelegateRecord","type","tokenRecord","parseTokenMetadataAuthorization","auth","accounts","authorizationRules","authorizationDetails","rules","authorizationData","authorityType","AuthorityType","MetadataDelegate","TokenDelegate","UnreachableCaseError","Holder","getSignerFromTokenMetadataAuthority","TOKEN_AUTH_RULES_ID","updateNftOperation","updateNftOperationHandler","updateNftBuilder","isEmpty","NoInstructionsToSendError","updateInstructionDataWithoutChanges","toInstructionData","updateInstructionData","shouldSendUpdateInstruction","isEqual","isRemovingVerifiedCollection","isOverridingVerifiedCollection","shouldUnverifyCurrentCollection","currentCreator","currentlyVerified","unverifyCollection","oldCollectionAuthority","oldCollectionIsSized","createUpdateInstruction","authorizationRulesProgram","updateArgs","updateMetadataInstructionKey","deleteNftOperation","deleteNftOperationHandler","deleteNftBuilder","ownerTokenAccount","parentEditionMint","parentEditionToken","createBurnInstruction","masterEditionMint","masterEditionToken","burnArgs","instructionKey","NftError","MetaplexError","cause","super","DelegateRoleRequiredDataError","TokenDelegateRole","Standard","Transfer","LockedTransfer","Sale","Utility","Staking","metadataDelegateRoleMap","CollectionV1","MetadataDelegateRole","Collection","DataV1","Data","ProgrammableConfigV1","ProgrammableConfig","metadataDelegateSeedMap","AuthorityItem","Use","DataItem","CollectionItem","ProgrammableConfigItem","delegateCustomDataMap","StandardV1","TransferV1","SaleV1","UtilityV1","StakingV1","LockedTransferV1","getMetadataDelegateRole","role","getMetadataDelegateRoleSeed","getDefaultDelegateArgs","hasCustomData","approveNftDelegateOperation","approveNftDelegateOperationHandler","approveNftDelegateBuilder","tokenMetadataAuthority","delegateArgsWithoutAuthData","createDelegateInstruction","delegateArgs","revokeNftDelegateOperation","revokeNftDelegateOperationHandler","revokeNftDelegateBuilder","createRevokeInstruction","revokeArgs","RevokeArgs","useNftOperation","useNftOperationHandler","useNftBuilder","numberOfUses","useAuthority","ExpectedSignerError","useAuthorityRecord","programAsBurner","burner","createUtilizeInstruction","utilizeArgs","approveNftUseAuthorityOperation","approveNftUseAuthorityOperationHandler","approveNftUseAuthorityBuilder","user","ownerTokenAddress","createApproveUseAuthorityInstruction","approveUseAuthorityArgs","revokeNftUseAuthorityOperation","revokeNftUseAuthorityOperationHandler","revokeNftUseAuthorityBuilder","createRevokeUseAuthorityInstruction","verifyNftCreatorOperation","verifyNftCreatorOperationHandler","verifyNftCreatorBuilder","createVerifyInstruction","verificationArgs","VerificationArgs","CreatorV1","unverifyNftCreatorOperation","unverifyNftCreatorOperationHandler","unverifyNftCreatorBuilder","createUnverifyInstruction","verifyNftCollectionOperation","verifyNftCollectionOperationHandler","verifyNftCollectionBuilder","collectionUpdateAuthority","collectionEdition","createVerifySizedCollectionItemInstruction","createVerifyCollectionInstruction","pubkey","collectionAuthorityRecord","isWritable","collectionMasterEdition","unverifyNftCollectionOperation","unverifyNftCollectionOperationHandler","unverifyNftCollectionBuilder","createUnverifySizedCollectionItemInstruction","createUnverifyCollectionInstruction","approveNftCollectionAuthorityOperation","approveNftCollectionAuthorityOperationHandler","approveNftCollectionAuthorityBuilder","createApproveCollectionAuthorityInstruction","newCollectionAuthority","revokeNftCollectionAuthorityOperation","revokeNftCollectionAuthorityOperationHandler","revokeNftCollectionAuthorityBuilder","revokeAuthority","createRevokeCollectionAuthorityInstruction","delegateAuthority","migrateToSizedCollectionNftOperation","migrateToSizedCollectionNftOperationHandler","migrateToSizedCollectionNftBuilder","nftPdas","createSetCollectionSizeInstruction","setCollectionSizeArgs","lockNftOperation","lockNftOperationHandler","lockNftBuilder","createLockInstruction","lockArgs","unlockNftOperation","unlockNftOperationHandler","unlockNftBuilder","createUnlockInstruction","unlockArgs","mintNftOperation","mintNftOperationHandler","mintNftBuilder","ataProgram","getAssociatedToken","createMintInstruction","splAtaProgram","mintArgs","transferCompressedNftOperation","transferCompressedNftOperationHandler","transferCompressedNftBuilder","compression","assetProof","ownership","tree_id","getAuthority","canopyDepth","getCanopyDepth","MerkleTree","root","leafIndex","leaf_id","leaf","proof","node","proofPath","createTransferInstruction","newLeafOwner","anchorRemainingAccounts","trim","dataHash","data_hash","creatorHash","creator_hash","nonce","prepareTransferCompressedNftBuilder","getAssetProof","asset","getAsset","ConcurrentMerkleTreeAccount","fromAccountAddress","transferNftOperation","transferNftOperationHandler","compressed","transferNftBuilder","fromOwner","fromToken","ownerTokenRecord","destinationTokenRecord","destination","destinationOwner","transferArgs","freezeDelegatedNftOperation","freezeDelegatedNftOperationHandler","freezeDelegatedNftBuilder","tokenAddressOrAta","createFreezeDelegatedAccountInstruction","thawDelegatedNftOperation","thawDelegatedNftOperationHandler","thawDelegatedNftBuilder","createThawDelegatedAccountInstruction","NftBuildersClient","create","printNewEdition","update","delete","revoke","use","approveUseAuthority","revokeUseAuthority","unverifyCreator","approveCollectionAuthority","revokeCollectionAuthority","migrateToSizedCollection","lock","unlock","transfer","freezeDelegatedNft","thawDelegatedNft","NftPdasClient","programId","div","findNftByAssetIdOperation","findNftByAssetIdOperationHandler","toMetadataFromReadApiAsset","toMintFromReadApiAsset","nftEdition","toNftEditionFromReadApiAsset","findNftByMintOperation","findNftByMintOperationHandler","commitment","loadJsonMetadata","accountAddresses","getMultipleAccounts","toMint","toMintAccount","toTokenAccount","downloadJson","mintAuthorityAddress","findNftByMetadataOperation","findNftByMetadataOperationHandler","findNftByTokenOperation","findNftByTokenOperationHandler","MAX_NAME_LENGTH","MAX_SYMBOL_LENGTH","MAX_URI_LENGTH","MAX_CREATOR_LEN","DATA_START","NAME_START","SYMBOL_START","URI_START","CREATORS_START","TokenMetadataGpaBuilder","GpaBuilder","whereKey","where","MetadataV1GpaBuilder","MetadataV1","selectUpdatedAuthority","whereUpdateAuthority","selectMint","whereMint","selectName","whereName","padEmptyChars","selectSymbol","whereSymbol","selectUri","whereUri","selectCreator","position","whereCreator","selectFirstCreator","whereFirstCreator","firstCreator","findNftsByCreatorOperation","findNftsByCreatorOperationHandler","gpaBuilder","get","findNftsByMintListOperation","findNftsByMintListOperationHandler","mints","metadataPdas","metadataInfos","GmaBuilder","findNftsByOwnerOperation","findNftsByOwnerOperationHandler","TokenGpaBuilder","whereOwner","whereAmount","getDataAsPublicKeys","findAllByMintList","findNftsByUpdateAuthorityOperation","findNftsByUpdateAuthorityOperationHandler","loadMetadataOperation","loadMetadataOperationHandler","uploadMetadataOperation","uploadMetadataOperationHandler","rawMetadata","getAssetsFromJsonMetadata","assetUris","replaceAssetsWithUris","uploadJson","walk","next","isMetaplexFile","replacements","clone","cloneDeep","NftClient","operations","execute","findByMetadata","findByToken","findAllByCreator","findAllByOwner","findAllByUpdateAuthority","load","refresh","uploadMetadata","nftModule","errorResolver","cusper","errorFromProgramLogs","logs","register","op","OperationClient","Map","operationConstructor","operationHandler","operationHandlers","set","OperationHandlerMissingError","signal","AbortController","Disposable","run","getOperationScope","operationModule","operationClient","ProgramClient","program","unshift","overrides","allForCluster","cluster","clusterFilter","allForCurrentCluster","nameOrAddress","ProgramNotRecognizedError","programModule","programClient","RpcClient","prepareTransaction","blockhashWithExpiryBlockHeight","recentBlockhash","lastValidBlockHeight","blockhash","getLatestBlockhash","getSigners","toTransaction","keypairs","identities","getSignerHistogram","prepared","defaultFeePayer","feePayer","rawTransaction","serialize","sendRawTransaction","parseProgramError","confirmTransaction","rpcResponse","FailedToConfirmTransactionError","err","FailedToConfirmTransactionWithResponseError","sendAndConfirmTransaction","confirmResponse","accountInfo","getAccountInfo","getUnparsedMaybeAccount","accountExists","publicKeys","accountInfos","getMultipleAccountsInfo","zipMap","getProgramAccounts","configOrCommitment","airdrop","assertSol","requestAirdrop","toNumber","getRent","rent","getMinimumBalanceForRentExemption","commitmentOrConfig","getSolanaExporerUrl","clusterParam","encodeURIComponent","setDefaultFeePayer","ReadApiConnection","RpcError","getAssetsByGroup","groupKey","groupValue","page","limit","sortBy","before","after","getAssetsByOwner","ownerAddress","isErrorWithLogs","FailedToSendTransactionError","regex","match","instructionNumber","parseInt","_programNotFoundError","UnknownProgramError","resolvedError","ParsedProgramError","rpcModule","rpcClient","toMetaplexFile","content","fileName","parseMetaplexFileContent","displayName","uniqueName","randomStr","getContentType","extension","getExtension","toMetaplexFileFromJson","jsonString","JSON","stringify","InvalidJsonVariableError","ArrayBuffer","Uint8Array","acc","metaplexFile","StorageClient","getUploadPriceForBytes","getUploadPriceForFile","download","fetch","arrayBuffer","parse","InvalidJsonStringError","storageModule","storageClient","createAccountOperation","createAccountOperationHandler","createAccountBuilder","space","newAccount","SystemProgram","createAccount","fromPubkey","newAccountPubkey","transferSolOperation","transferSolOperationHandler","transferSolBuilder","to","basePubkey","seed","toPubkey","SystemBuildersClient","transferSol","SystemClient","systemModule","system"],"sourceRoot":""}